import fs from 'node:fs/promises';
import { parse } from 'csv-parse';
import inquirer from 'inquirer';
import {connectToDatabase} from './db.js';
import test4empty from './util/empty.js';

let dbFileName = `publications.sqlite`;
let db = await connectToDatabase(dbFileName); // connect to the database

let crypto;
try {
  crypto = await import('node:crypto');
} catch (err) {
  console.error('crypto support is disabled!');
} 

// preparing for a possible interface

/* === PRIMARY SETTING UP for `articles` table (considered the primary node table) === */
// for this scenario, the nodes are the titles of the articles and their corresponding ids are generated by Zotero at export time as CSV
let nodesTabelHeadStructure = `Id,Label,` + `Year,Author,JournalAccr,Kw`; // Mind that the `Id` and `Label` should be strict as such. The rest of the atributes may be of your own choosing
let nodesIdxsAreArrays = [2, 5]; // The values at these indexes are actualy arrays
let nodesTableRecordMarcherIdxs = [0, 3, 1, 2, 4, 5]; // These are the indexes of every value in an array representing a line from the CSV. This is useful when you want some other entity as node value (`Label`)
let nodesTableValPlaceholders   = `?, ?, ?, json(?), ?, json(?)`; // the number of the question marks should match the number of the values in the head (`nodesTabelHeadStructure`). The coding as JSON is essential for quering.
let mainTablename = `articles`;
// the query needed to create `articles` table
let tableExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='${mainTablename}'`;
// QUERY needed for creating the table
let tblCreateQuery = `
CREATE TABLE articles
(
  Id           VARCHAR(10),
  Label        VARCHAR(250),
  Year         INTEGER,
  Author       json,
  JournalAccr  VARCHAR(20),
  Kw           json,
)
`;


/* === Descriptors table === */
let descriptorsExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='descriptors'`;
let descriptorsTabelHeadStructure = `hash,descriptor,Years,JournalAccrs`;
let descriptorsTableValPlaceholders   = `?, ?, json(?), json(?)`;
let tblDescriptorsCreateQuery = `
CREATE TABLE IF NOT EXISTS descriptors (
  id           INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
  hash         VARCHAR(50),
  descriptor   VARCHAR(250),
  Years        json,
  JournalAccrs json
)
`;
// create `descriptors` table if it doesn't exists already
db.get(descriptorsExistsQuery, async function clbkDesrsTblExists (error, count) {
  if (error) {
    throw new Error(`I've looked for the table descriptors, but this error appeared ${error.message}`, error);
  } else if (count['result'] === 0) {
    db.run(tblDescriptorsCreateQuery);
  } else if (count['result'] === 1) {
    console.log(`Table descriptors already exists, silly ol' chap!`);
  }
});

/* === Edges table === */
let edgesExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='edges'`;
let tblEdgesCreateQuery = `
CREATE TABLE IF NOT EXISTS edges (
  id           INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
  Source       VARCHAR(50),
  Target       VARCHAR(50),
  Weight       INTEGER,
  Type         VARCHAR(20),
  Year         INTEGER,
  JournalAccr  json
)
`;// [Source] the id of the concept [Target] the id of the article [Weight:integer] 1 [Type:string] Directed [Kind:string] descriptor [Year:integer] 2002 (the year when the article was published) [JournalAccr:string] DL'09

// create `edges` table if it doesn't exists already
db.get(edgesExistsQuery, async function clbkTblEdgesExists (error, count) {
  if (error) {
    throw new Error(`I've looked for the table edges, but this error appeared ${error}`);
  }  else if (count['result'] === 0) {
    db.run(tblEdgesCreateQuery);
  } else if (count['result'] === 1) {
    console.log(`Table edges already exists, silly ol' chap!`);
  }
});

/**
 *The function is populating the `articles` table with the data 
 *from the source file
 *
 */
async function populateTable () {
  // read the file source
  const fd = await fs.open("./sourcefile/data-prima-forma.csv");
  fd.createReadStream()
      .pipe(parse({ delimiter: ",", from_line: 2 }))
      .on("data", function clbkWorkOnRow(row) {
        // console.log(`Valorile rândului sunt ${row[0]}, apoi ${row[1]}`);

        // prepare and load the data
        let prepStmt = db.prepare(`INSERT INTO articles(${nodesTabelHeadStructure}) VALUES (${nodesTableValPlaceholders})`);
        // prepStmt.run([row[0],row[3],row[1],row[2],row[4],row[5]], function clbkerrorinsert(error) {
        prepStmt.run(nodesTableRecordMarcherIdxs.map((idx) => {
          // set JSON value
          if (nodesIdxsAreArrays.includes(idx)) {            
            let valuesArr = {
              values: row[idx].split('; ')
            };
            if (valuesArr['values'].length > 0) {
              console.log(`The values when we have actualy an array ${JSON.stringify(valuesArr)}`);
              return `${JSON.stringify(valuesArr)}`;
            } else {
              console.log(`I have one value here ${row[idx]}`);
              return `{"values":[${row[idx]}]}`;
            }

          } else {
            return row[idx];
          }
        }), function clbkerrorinsert(error) {
          if (error) {
            throw new Error(`At inserting the data, this error appeared: ${error.message}`);
          } else {
            console.log(`Inserted row: ${this.lastID}`);
          }
        });
        prepStmt.finalize();

        // check if all was loaded OK
        // db.each("SELECT rowid AS id, title FROM articles", function(err, row) {
        //   console.log(row.id + ": " + row.title);
        // });
      })
      .on("end", function () {
          console.log("finished");
      })
      .on("error", function (error) {
          console.log(error.message);
      }); 
}

try {
  /*
  * === SETTING UP THE DATABASE ===
  * Investigate if the table exists. If it exists, ask user if she/he wants to wipe clean the data.
  * If it doesn't exists, create the table
  * The user can opt for cleaning the table and repopulating with fresh data from the source.
  * As soon as the data was wipped, the table will be repopulated with the data from the source.
  */
  db.get(tableExistsQuery, async function clbkTableExists (error, count) {
    if (error) {
      throw new Error(`I've looked for the table, but this error appeared ${error}`);
    } else if (count['result'] === 1) {
      console.log(`Table articles already exists, silly ol' chap!`);

      // put an option to cleaning the existing data (https://betterprogramming.pub/how-to-create-beautiful-command-line-interactions-with-node-js-2fcdfbbac62c)
      inquirer.prompt([
        {
          type: 'checkbox',
          name: 'wipearticles',
          message: 'Would you like me to clean the data of the articles table?',
          default: 'no',
          choices: [
            {name: 'no'},
            {name: 'yes', checked: false},
          ],
        }
      ]).then(async function getMeAnswers (answers) {
        let chain = [
          `DELETE FROM ${mainTablename}`,
          `DELETE FROM descriptors`,
          `DELETE FROM edges`
        ];
        // if you want to clean the data from the table, you must have an `yes` value for an answer 
        if (answers.wipearticles == 'yes') {
      
          for (let query of chain) {
            db.run(query, function clbkChainTrigger (error) {
              if (error) {
                throw new Error (`Wipping table data raised this error: ${error}`);
              } else {
                console.log(`I've wipped clean the data from the tables`);
              }
            });
          }
          await populateTable();
        }
      }).catch((error) => {
        if (error.isTtyError) {
          throw new Error (`Prompt couldn't be rendered in the current environment`);
        } else {
          throw new Error (`When cleaning descriptors table the following error was raised: ${error}`);
        }      
      });
    } else {
      db.exec(tblCreateQuery);
      await populateTable();
    }
  });

  /*
  * Case study:
  * I want every piece of a keyword list to become an entity with an id (md5 generated)
  * 
  * #1 Create a table `concepts` where new records are the individual keywords from the article records
  *  - Create a function which adds a record as long as the `Label` was not already inserted
  *  - The record should look like: `[Id]CD4GRTT [Label]machine learning
  * #2 Create a table of `edges` where the the following conditions are met in the following workflow:
  *  - take one record from the `concepts` table and look up for all the records from the `articles` table where it appears in the `kw` field.
  *  - if it is matched, create a record in the table `edges` where you have te following fields: 
  *   - [Source] the id of the concept [Target] the id of the article [Weight:integer] 1 [Type:string] Directed [Kind:string] descriptor [Year:integer] 2002 (the year when the article was published) [JournalAccr:string] DL'09
  */

  /**
   * Function creates a new nodes table for a particular atribute from the original `articles` table
   * In this case we want to pickup every `kw` data, transform it into and array and for every element create a new record
   */
  async function semicolonArrElems2entities (record, attributeName) {
    // parse every record in the table `articles`.
    // check if the the chosen attribute (column name) exists. If not, pass to the next record
  }

 
  // Parse all data from articles table and build descriptor and edges tables
  db.all(`SELECT * FROM articles`, function clbkparseDataOneTbl (error, rows) {
    if (error) {
      throw new Error (`Selecting all data from the table articles, this error was thrown: ${error}`);
    }

    rows.forEach((row) => {
      if (row === undefined) {
        console.log(`Something's very wrong`);
      }
      if (!test4empty(row['Kw'])) {
        let KwObj = JSON.parse(row['Kw']);
        let kwArr = KwObj['values'], i;

        // You are parsing the keywords array
        for (i = 0; i < kwArr.length; i++) {
          // console.log(kwArr[i].trim());

          function clbkChec4ExistanceOfDescr (error, result) {

            if (error) {
              throw new Error (`Searching for the same descriptor, I came upon this error: ${error.message}`, error);
            } else if (result === undefined) {
                // The current descriptor doesn't exist in `despriptors` tabel. Proceed to adding it 

                // #A prepare and load the data FIXME:
                // let prepStmt = db.prepare(`INSERT INTO descriptors(${descriptorsTabelHeadStructure}) VALUES (${descriptorsTableValPlaceholders})`);

                /*
                ROW VALUE
                {
                  Id: '5RPFTWAE',
                  Label: 'VISIT: A content management and exploration system for mobile augmented reality in the context of digital humanities and cultural heritage',
                  Year: 2023,
                  Author: '{"values":["Serres, Barthélémy","Létienne, Damien","Roussey, Olivier","Venturini, Gilles"]}',
                  JournalAccr: 'JOCCH',
                  Kw: '{"values":["digital humanities","cultural heritage","content management systems","Mobile augmented reality"]}'
                }
                */
                console.log(kwArr[i]);
                
                let articlesRowIdxsReordered = [];

                // create the hash
                const hash = crypto.createHash('sha256');
                hash.update(`${kwArr[i]}`);

                articlesRowIdxsReordered.push(hash.digest('hex'));
                articlesRowIdxsReordered.push(kwArr[i]);
                articlesRowIdxsReordered.push(`${JSON.stringify([row['Year']])}`);
                articlesRowIdxsReordered.push(`${JSON.stringify([row['JournalAccr']])}`);

                // #B run the query
                // prepStmt.run(articlesRowIdxsReordered, function clbkerrorinsert(error) {
                //   if (error) {
                //     throw new Error(`At inserting the data, this error appeared: ${error.message}`);
                //   } else {
                //     console.log(`Inserted row: ${this.lastID}`);
                //   }
                // });

                // #C Finalize!
                // prepStmt.finalize();
            } else {
                return;
                // #A prepare and load the data
                // let prepStmt = db.prepare(`UPDATE descriptors SET (${descriptorsTabelHeadStructure}) VALUES (${descriptorsTableValPlaceholders})`);

                // UPDATE your_table
                // SET your_column = json_set(your_column, '$.name', '"John Doe"')
                // WHERE id = 1;
            }
          }

          // #1 Search `descriptors` table for the same value
          db.get(`SELECT DISTINCT descriptor FROM descriptors WHERE descriptor="${kwArr[i]}"`, clbkChec4ExistanceOfDescr);
  
          /*
          
          SELECT *
          FROM articles
          WHERE id IN (
            SELECT Id
            FROM articles
            WHERE json_extract(Kw, '$.values') LIKE '%"digital libraries"%'
          );
          
          */
        }
      }
    });
  });

/*

Given two rows in an Sqlite3 table containing a column where cell value is a JSON:
- create an Sqlite3 query that searches a value existing as element of an array in the JSON if it exists in other rows in the same column
- create a subset with those rows.


SELECT *
FROM articles
WHERE json_extract(Kw, '$.values') LIKE '%"digital libraries"%';

SELECT *
FROM articles
WHERE id IN (
  SELECT Id
  FROM articles
  WHERE json_extract(Kw, '$.values') LIKE '%"digital libraries"%'
);

*/ 

  // db.close(); // in the end close connection with the database
} catch (error) {
  console.log(error);
}

