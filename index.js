import fs from 'node:fs/promises';
import { finished } from 'stream/promises';
import { parse } from 'csv-parse';
import inquirer from 'inquirer';
import {connectToDatabase} from './db.js';
import test4empty from './util/empty.js';
import {inspect} from 'util';

let sourcefilename = `./sourcefile/data-adoua-forma.csv`;
let dbFileName = `publications.sqlite`;
let db = await connectToDatabase(dbFileName); // connect to the database

let crypto;
try {
  crypto = await import('node:crypto');
} catch (err) {
  console.error('crypto support is disabled!');
} 

try {
  // preparing for a possible interface

  /* === PRIMARY SETTING UP for `articles` table (considered the primary node table) === */
  // for this scenario, the nodes are the titles of the articles and their corresponding ids are generated by Zotero at export time as CSV
  let nodesTabelHeadStructure = `Id,Label,` + `Year,Author,JournalAccr,Kw`; // Mind that the `Id` and `Label` should be strict as such. The rest of the atributes may be of your own choosing
  let nodesIdxsAreArrays = [2, 5]; // The values at these indexes are actualy arrays
  let nodesTableRecordMarcherIdxs = [0, 3, 1, 2, 4, 5]; // These are the indexes of every value in an array representing a line from the CSV. This is useful when you want some other entity as node value (`Label`)
  let nodesTableValPlaceholders   = `?, ?, ?, json(?), ?, json(?)`; // the number of the question marks should match the number of the values in the head (`nodesTabelHeadStructure`). The coding as JSON is essential for quering.
  let mainTablename = `articles`;
  // the query needed to create `articles` table
  let tableExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='${mainTablename}'`;
  // QUERY needed for creating the table
  let tblCreateQuery = `
  CREATE TABLE IF NOT EXISTS articles (
    Id           VARCHAR(10),
    Label        VARCHAR(250),
    Year         INTEGER,
    Author       json,
    JournalAccr  VARCHAR(20),
    Kw           json
  )
  `;
  /* === Descriptors table === */
  let descriptorsExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='descriptors'`;
  let descriptorsTabelHeadStructure = `hash,descriptor,Years,JournalAccrs`;
  let descriptorsTableValPlaceholders   = `?, ?, json(?), json(?)`;
  let tblDescriptorsCreateQuery = `
  CREATE TABLE IF NOT EXISTS descriptors (
    id           INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    hash         VARCHAR(50),
    descriptor   VARCHAR(250),
    Years        json,
    JournalAccrs json
  )
  `;
  /* === Edges table === */
  let edgesExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='edges'`;
  let edgesTabelHeadStructure = `Source,Target,Weight,Type,Kind,Article,Year,JournalAccr`;
  let edgesTableValPlaceholders = `?, ?, ?, ?, ?, ?, ?, ?`;
  let tblEdgesCreateQuery = `
  CREATE TABLE IF NOT EXISTS edges (
    id           INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    Source       VARCHAR(50),
    Target       VARCHAR(50),
    Weight       INTEGER,
    Type         VARCHAR(20),
    Kind         VARCHAR(20),
    Article      VARCHAR(300),
    Year         INTEGER,
    JournalAccr  VARCHAR(20)
  )
  `;// [Source] the id of the concept [Target] the id of the article [Weight:integer] 1 [Type:string] Directed [Kind:string] descriptor [Year:integer] 2002 (the year when the article was published) [JournalAccr:string] DL'09

  // initial stages when all tabels are created
  db.serialize(() => {
    // create `articles` table if it doesn't exists already
    db.get(tableExistsQuery, async function clbkArtsTblExists (error, count) {
      if (error) {
        throw new Error(`I've looked for the table articles, but this error appeared ${error.message}`, error);
      } else if (count['result'] === 0) {
        db.run(tblCreateQuery);
      } else if (count['result'] === 1) {
        console.log(`Table articles table exists, ol' chap!`);
      }
    });

    // create `descriptors` table if it doesn't exists already
    db.get(descriptorsExistsQuery, function clbkDesrsTblExists (error, count) {
      if (error) {
        throw new Error(`I've looked for the table descriptors, but this error appeared ${error.message}`, error);
      } else if (count['result'] === 0) {
        db.run(tblDescriptorsCreateQuery);
      } else if (count['result'] === 1) {
        console.log(`Table descriptors already exists, jolly lassie!`);
      }
    });

    // create `edges` table if it doesn't exists already
    db.get(edgesExistsQuery, function clbkTblEdgesExists (error, count) {
      if (error) {
        throw new Error(`I've looked for the table edges, but this error appeared ${error}`);
      }  else if (count['result'] === 0) {
        db.run(tblEdgesCreateQuery);
      } else if (count['result'] === 1) {
        console.log(`Table edges already exists, silly bat!`);
      }
    });

    // hidrating descriptors and edges tables => stagesProcessing()
    db.get(tableExistsQuery, async function clbkArtsTblExists (error, count) {
      if (error) {
        throw new Error(`Table articles, trying to hidrate the other tables but: ${error.message}`, error);
      }
      if (count['result'] === 1) {
        await stagesProcessing();
      }
    });
  });

  /**
   * Function is a callback for `on("data", clbkWorkOnRow)`
   * This is the place whre table articles gets hidrated with data from the chunk
   * @param {Object} row 
   */
  function processDataRow(row) {
    try {
      // prepare an Sqlite3 statement and load the data
      let prepStmt = db.prepare(`INSERT INTO articles(${nodesTabelHeadStructure}) VALUES (${nodesTableValPlaceholders})`);
      // Insert into the articles the data
      prepStmt.run(nodesTableRecordMarcherIdxs.map((idx) => {
        // set JSON value
        let now = new Date();
        if (nodesIdxsAreArrays.includes(idx)) {            
          let valuesArr = {
            values: row[idx].split('; ')
          };
          if (valuesArr['values'].length > 0) {
            // console.log(`The values when we have actualy an array ${JSON.stringify(valuesArr)}`); // {"values":["Silva, Paulo","Matos, Miguel","Barreto, João"]}
            return `${JSON.stringify(valuesArr)}`;
          } else {
            // console.log(`I have one value here ${row[idx]}`);            
            let logline = `[${now.toUTCString()}] «clbkWorkOnRow(row)»: I have inserted in article table: ${row[idx]}.\n`;
            fs.appendFile(`./logs/main.log`, `${logline}`, 'utf8');
            return `{"values":[${row[idx]}]}`;
          }  
        } else {
          let logline = `[${now.toUTCString()}] «clbkWorkOnRow(row)»: I have inserted in article table: ${row[idx]}.\n`;
          fs.appendFile(`./logs/main.log`, logline, 'utf8');
          return row[idx];
        }
      }), function clbkerrorinsert(error) {
        if (error) {
          throw new Error(`At inserting the data in the table ${mainTablename}, this error appeared: ${error}`);
        } else {
          console.log(`In the table ${mainTablename} I've inserted row: ${this.lastID}`);
        }
      });
      prepStmt.finalize();
    } catch (error) {
      throw new Error(error);
    }
  };

  /**
   *The function is populating the `articles` table with the data 
  *from the source file
  */
  async function populateArticlesTable () {
    try {
    // read the file source
    const fd = await fs.open(sourcefilename);
    fd.createReadStream()
        .pipe(parse({ delimiter: ",", from_line: 2, skip_empty_lines: true, trim: true }))
        .on("data", function clbkWorkOnRow(row) {
          processDataRow(row);
        })
        .on("end", function () {
            console.log(`I've finished reading the CSV. Data is still being writen in the table`);
        })
        .on("error", function (error) {
            console.log(error.message);
        });
    } catch (error) {
      throw new Error (error);
    }
  };

  /**
   * The function will process the rest of the steps: creating data in descriptors and building edges
   */
  async function stagesProcessing () {
    try {
      db.serialize(() => {
        // Operation to creat data in the articles table and restart de cycle if user confirms it
        db.get(tableExistsQuery, async function clbkTblArticles (error, count) {
          try {
            if (error) {
              throw new Error(`I've looked for the table articles, but this error appeared ${error}`);
            }
            // if the articles table exists, check further if it has any records
            if (count['result'] === 1) {
              // investigate how many records are in the `articles` table
              db.get(`SELECT COUNT(*) AS count FROM ${mainTablename}`, async function clbkHowmany (error, nr) {
                if (error) {
                  throw new Error(`I wanted to count the number or rows in ${mainTablename}, but this error appeared ${error}`);
                }
                
                let nrOfRows = nr.count; // number of records in articles table
                // If records exist, rework all steps if user confirms it with yes (a new source file is to be processed)
                if (!nrOfRows > 0) {
                  console.log(`Table articles already exists counting ${nrOfRows} of rows.`);
                  // this is the case when table articles exists but has no records added
                  await populateArticlesTable();
                  await stagesProcessing();
                }            
              });
            }
          } catch (error) {
            throw new Error (`Creation and hidration with data of the articles table has failed: ${error}`);
          }
        });

        // calls descriptorAndEdgeCreator() on each row fron articles table
        db.each(`SELECT * FROM articles`, async function clbkparseDataOneTbl (error, row) {
          if (error) {
            throw new Error (`Selecting all data from the table articles, this error was thrown: ${error}`);
          }
            // in case the keywords array value doesn't come empty
            if (!test4empty(row['Kw'])) {
              await descriptorAndEdgeCreator(row); 
            }
        });                     
      });
      await enrichDescriptor();
    } catch (error) {
      throw new Error (error);
    }
  };

  /* === THE HELPER FUNCTIONS === */

  /**
   * Function creates a new record in the `edges` table
   */
  async function createAnEdge (recordArray) {
    // console.log(`I'm ready to insert the following edge: ${recordArray}`);
    try {
      db.get(`SELECT * FROM edges WHERE Source="${recordArray[0]}" AND Target="${recordArray[1]}"`, function clbkCheck4Existing (error, edge) {

        if (error) {
          throw new Error(`I was preparing to investigate if there is already an edge created prior for the inputed Souce and Target, and this error popped up: ${error}`);
        }
  
        // the edge doesn't exist, so create one
        if (edge === undefined) {
          // #A Prepare the statement
          let prepStmt = db.prepare(`INSERT INTO edges(${edgesTabelHeadStructure}) VALUES (${edgesTableValPlaceholders})`);
  
          // #B run the query
          prepStmt.run(recordArray, function clbkInsertEdge (error) {
            if (error) {
              throw new Error(`Inserting an edge, this error appeared: ${error.message}`);
            } else {
              console.log(`Inserted edge no: ${this.lastID}`);
            }
          });
  
          // #C Finalize!
          prepStmt.finalize();
        } else {
          return console.log(`The edge exists already, I will not created again. Move along, nothing to see here!`);
        }
      });      
    } catch (error) {
      throw new Error(error);
    }
  };

  /**
   * The function adds one value to an array existing in a JSON value of a cel in a particular table
   * @param {*} tableName 
   * @param {*} columName 
   * @param {*} keyName 
   * @param {JSON} value 
   */
  function addOneValueToAJSONarr (tableName, columName, keyName, value, hash) {
    let query = `
      UPDATE ${tableName}
      SET ${columName} = json_set(${columName}, '$.${keyName}', ?)
      WHERE hash = ?;
    `;
    db.run(query, [value, hash], function clbkUpdateOneArr (error) {
      if (error) {
        throw new Error (`At the moment of updating the value, the following error popped up: ${error.message}`);
      }
      console.log(`${this.changes} enrichment for descriptor: ${hash}`);
    });
  }

  let clearing = new Set(); // clearing house for the descriptors
  /**
   * Function pushes descriptors in `descriptors` table.
   * It also pushes the first edge in the edge table. There are 20253 descriptors even when they double (10877 unique descriptors)
   * It checks is the descriptor exists already, and if it does, 
   * It checks if the other attributes are already in the columns meant to gather it (year[array] and the journal accronim[array])
   * Criteria: `SELECT DISTINCT descriptor FROM descriptors WHERE descriptor="${descriptor}"` 
   * @param {String} descriptor 
   */
  async function descriptorAndEdgeCreator (row) {
    try {
      let KwObj = JSON.parse(row['Kw']); // parse the object value in in Kw
      let kwArr = KwObj['values'];       // set `kwArr` -> should be an array
      // console.log(`The descriptor array for this row is ${kwArr}`);
  
      for (let descriptor of kwArr) {
        // console.log(`The descriptor is ${descriptor} and is in the clearing ${clearing.has(descriptor)}`);
        if (!clearing.has(descriptor) && !test4empty(descriptor)) {
          clearing.add(descriptor);
  
          // first search if there is a already the same descriptor inserted in the table.
          db.get(`SELECT * FROM descriptors WHERE descriptor="${descriptor}"`, async function clbkDescrPaitToArts (error, descrData) {
            try {
              if (error) {
                throw new Error (`I was creating a descriptor when ${error}`);
              }

              if (descrData !== undefined && descriptor == descrData.descriptor) {
                console.log(`I will not write another one because I found it already. Look: ${descrData.descriptor}. If you need to write fresh descriptors table, just delete it first.`);
                return;
              } else {
                // #A prepare and load the data
                let prepStmt = db.prepare(`INSERT INTO descriptors(${descriptorsTabelHeadStructure}) VALUES (${descriptorsTableValPlaceholders})`);
    
                /* === RECORD CREATION STAGE === */
                const hash = crypto.createHash('sha256').update(descriptor); // create the needed hash (I chose to use a hash representation of the descriptor for which I know it will be trully unique).
    
                /* create and hidrate the array */
                let descriptorsRowIdxsReordered = []; // the array of the values bound to be inserted into the table
                descriptorsRowIdxsReordered[0] = hash.digest('hex'); // the value for `hash` column
                descriptorsRowIdxsReordered[1] = descriptor;  // the value for `descriptor` column
                descriptorsRowIdxsReordered[2] = `${JSON.stringify({values: [row['Year']]})}`; // the value for `Year` column
                descriptorsRowIdxsReordered[3] = `${JSON.stringify({values: [row['JournalAccr']]})}`; // the value for `JournalAccr` column
    
                // #B run the query
                prepStmt.run(descriptorsRowIdxsReordered, function clbkerrorinsert(error) {
                  if (error) {
                    throw new Error(`At inserting the data in the descriptors table, this error appeared: ${error}`);
                  }
                  console.log(`Creating a fresh descriptor: ${this.lastID}`);
                });
    
                // #C Finalize!
                prepStmt.finalize();
    
                // Create all the edges here and insert it in the edges table
                let edge = [];
                edge[0] = descriptorsRowIdxsReordered[0]; // [Source:string]
                edge[1] = row['Id']; // [Target:string] this value is the id for the name of the article
                edge[2] = 1; // [Weight:integer]
                edge[3] = "Directed"; // [Type:string]
                edge[4] = "descriptor"; // [Kind:string]
                edge[5] = row['Label']; // [ArticleTitle:string]
                edge[6] = row['Year']; // [Year:integer]
                edge[7] = row['JournalAccr']; // [JournalAccr:string]
    
                if (edge.length === 8) {
                  await createAnEdge(edge);
                }
    
                // let TrackerObj = {
                //   descriptor,
                //   hash: descriptorsRowIdxsReordered[0],
                //   origin: row             
    
                // fs.writeFile('./tracker.json', `${JSON.stringify(TrackerObj , null, 2)},`, 'utf8');
              }            
            } catch (error) {
              throw new Error (error);
            }
          });
        }
      }      
    } catch (error) {
      throw new Error(error);
    }
  };

  /**
   * Function generates al the possible pairing between certain identifiers
   * Helper function for `createArticleToArticleEdge` function
   * @param {Array} arr 
   * @returns {Array} combinations
   */
  function* generateDistinctPairs(array) {
    for (let i = 0; i < array.length; i++) {
      for (let j = i + 1; j < array.length; j++) {
        yield [array[i], array[j]];
      }
    }
  };

  /**
   * Function creates all possible edges having for source and target article identifiers.
   * It is the callback for the foreach in the `articlesGraphCreator` function
   * Receives as value of the parameter one whole row from descriptor's table 
   * @param {Object} descriptorRecord 
   */
  async function createArticleToArticleEdge (descriptorRecord) {
    try {
      // console.log(`${inspect(descriptorRecord['hash'])}`);    
      // use the hash to search for all the records in the entities table
      if (descriptorRecord['hash']) {
        // console.log(`${descriptorRecord['hash']}`);
        db.all(`SELECT * FROM edges WHERE Source="${descriptorRecord['hash']}"`, async (error, records) => {
          if (error) {
            throw new Error (`Something happened when I tried to fetch the data: ${error}`);
          }
          // console.log(records);
          let articlesIds = records.map(rec => rec['Target']);

          // console.log(`The Ids I need are  ${JSON.stringify(articlesIds)}`);
          if (articlesIds.length >= 2 && articlesIds.length <= 5) {
            // console.log(`This segment has ${articlesIds.length} Ids`);
            // if (articlesIds.length > 5) {
            //   console.log(`Better check this one out ${JSON.stringify(articlesIds)} for the ${descriptorRecord['hash']}\n`);
            //   fs.appendFile('./biggerthan5.csv', `${JSON.stringify(articlesIds)} for the ${descriptorRecord['hash']}\n`, 'utf8');
            // }
            
            
            // You better have at least 8 cores for this :)))) MUHHAHAHAHAHAHAHA!
            let newEdges = generateDistinctPairs(articlesIds); // gives you all the possible combinations
            for (let combo of newEdges) {
              // let sourceRowData = await getRecordsFromTable(articles, Id, combo[0]);
              // let targetRowData = await getRecordsFromTable(articles, Id, combo[1]);
              db.each(`SELECT * FROM 'articles' WHERE 'Id'="${combo[0]}"`, (error, combo0Rec) => {
                if (error) {
                  throw new Error (`An error has been issued when accessing the articles table trying to get data for the article in the <Source> position: ${error}`);
                }
                // data for the article in the `Source` position
            
                // And down to the pyramid of dooooooommmmmm! Save me Obi Wan! You are my only hope!
                db.each(`SELECT * FROM 'articles' WHERE 'Id'="${combo[1]}"`, async (error, combo1Rec) => {
                  if (error) {
                    throw new Error (`An error has been issued when accessing the articles table trying to get data for the article in the <Target> position: ${error}`);
                  }
                  // data for the article in the `Target` position
                  let newArticleEdge = [...combo, 1, "Undirected", descriptorRecord['descriptor'], " ", `${combo0Rec['Year']},${combo1Rec['Year']}`,  `${combo0Rec['JournalAccr']},${combo1Rec['JournalAccr']}`];
                  console.log(`The inbound edge: ${newArticleEdge}`);
                  let line = newArticleEdge.join('","') + '\n';
                  if (newArticleEdge.length === 8) {
                    fs.appendFile(`./articledges.csv`, line, 'utf8');
                    // await createAnEdge(newArticleEdge);
                  }
                });  
              });
            }
          }
        });
      }
    } catch (error) {
      throw new Error(error);
    }
  };

  /**
   * Function is creating edges for every articles that are linked through a common descriptor
   * The descriptor is treated as a verb (name of the edge)
   * @param {*} row The row of data for an article who's keywords are being processed
   */
  function articlesGraphCreator (row) {
    let KwObj = JSON.parse(row['Kw']); // parse the object value in in Kw
    let kwArr = KwObj['values'];       // set `kwArr` -> should be an array
    // console.log(`The descriptor array for this row is ${JSON.stringify(kwArr)}`);

    for (let descriptor of kwArr) {
      db.each(`SELECT * FROM descriptors WHERE descriptor="${descriptor}"`, function clbkDescrPaitToArts (error, descrData) {
        if (error) {
          throw new Error (`Selecting all data from the table descriptors, this error was thrown: ${error}`);
        }        
        // console.log(`${inspect(descrData)}`);
        createArticleToArticleEdge(descrData);
      });
    }
  }


  /* === DESCRIPTORS SECTION === */

  // Function to fetch a row based on a descriptor
  async function fetchRowByDescriptor(descriptor, dbname) {
    return new Promise((resolve, reject) => {
      const query = `SELECT * FROM descriptors WHERE descriptor="${descriptor}"`;

      db.get(query, (err, row) => {
        db.close();

        if (err) {
          reject(err);
        } else {
          resolve(row);
        }
      });
    });
  };

  async function enrichDescriptor () {
    try {
      // Use the generator function to iterate over the rows
      // const query = `SELECT * FROM ${mainTablename}`;
  
      // db.all(query, async (error, result) => {

      // });


// process descriptors
let prepStmt = db.prepare(`SELECT * FROM articles`);
prepStmt.each(async function clbkForEveryRow (error, row) {
  if (error) {
    throw new Error (`Processing the descriptors took a hard left :D`);
  }
  if (test4empty(row)) {
    throw new Error(`It seems I found an empty row: ${error}`);
  }
  // in case the keywords array value doesn't come empty
  if (!test4empty(row['Kw'])) {
    console.log(row)
  }
}, function (error, count) {
  if (error) {
    throw new Error (`At the finalization of the processing 4 descriptors, this error was thrown: ${error}`);
  }
  console.log(`I've processed data for ${count} descriptors`);
  // 
});
prepStmt.finalize();




      // const iteration = articlesGenerator.next();

      // if (iteration.done) {
      //   // Generator has finished
      //   // db.close();
      //   return;
      // } else {

      // }
      // const articleRow = iteration.value; // a row from the articles table [generator]


      // Continue iterating
      // setImmediate(iterateGenerator);
    } catch (error) {
      throw new Error (error);
    }
  }

  /**
   * Function will enrich all the records in the descriptors table
   * It will be called for every keyword in the article's keyword array
   * It will add years for the same descriptor where this one shows up for the articles
   * It will create edges in certain cases
   * @param {String} descriptor
   * @param {Object} row is a row from the `articles` table
   */
  function enrichDescriptorNodes (descriptor, row) {
    // get my data
    db.get(`SELECT * FROM descriptors WHERE descriptor="${descriptor}"`, async function clbkChec4ExistanceOfDescr (error, result) {
      if (error) {
        throw new Error (`Searching for the descriptor, I came upon this error: ${error}`);
      } 
      let now = new Date();
      if (result === undefined) {
        console.log(`In descriptor's table I don't have the one you search. Value is undefined`);
        fs.appendFile(`./logs/enrichmentIssues.log`, `[${now.toUTCString()}] : I don't have a record in descriptors. Value undefined\n`, 'utf-8');
        return;
      }     

      /* === Work with the existing Years array === */
      // Extract the year and compare with the values already existing
      let yearsParsed = JSON.parse(result['Years']);   // transform the JSON text into an object
      let resultExistingYears = yearsParsed['values']; // extract the array

      // Check to have a real array in the value. Bit me very nasty!
      if (typeof(resultExistingYears) === 'string') {
        resultExistingYears = JSON.parse(resultExistingYears);
      }

      // first test if there is an array of years
      if (Array.isArray(resultExistingYears)) {
        if (row['Year'] !== undefined && !resultExistingYears.includes(row['Year'])) {
          resultExistingYears.push(row['Year']);
        } // update the years to include the new year as well
      } else {
        throw new Error (`There is something fishy with this tranformation. 
        I expected an array and came about this ${resultExistingYears} which is revealed to be: ${inspect(resultExistingYears)}. 
        Test 4 arr: ${Array.isArray(resultExistingYears)}
        The resultExistingYears back to JSON is: ${JSON.stringify(resultExistingYears)}.
        Is it a string: ${typeof(resultExistingYears) === 'string'}.
        But noow ${Array.isArray(JSON.parse(resultExistingYears))}
        `);
      }

      /* === Work with the existing JournalAccrs array === */
      let JournalAccrs = JSON.parse(result['JournalAccrs']);  // transform the JSON text into an object
      let resultExistingJournalAccrs = JournalAccrs['values'];// extract the array

      // Check to have a real array in the value. Bit me very nasty!
      if (typeof(resultExistingJournalAccrs) === 'string') {
        resultExistingJournalAccrs = JSON.parse(resultExistingJournalAccrs);
      }

      // first test id there is an aray of values
      if (Array.isArray(resultExistingJournalAccrs)) {
        if (row['JournalAccr'] !== undefined && !resultExistingJournalAccrs.includes(row['JournalAccr'])) {
          resultExistingJournalAccrs.push(row['JournalAccr'])
        } // update de Accrs to include the new journal accr as well
      } else {
        throw new Error (`There is something fishy with this tranformation. I expected an array and came about this ${inspect(resultExistingJournalAccrs)}`);
      }

      let shoutout = `For the existing descriptor with id <${result.descriptor}>, value of JournalAccrs is ${result['JournalAccrs']}, and ${result['Years']} transformed into ${JSON.stringify(JournalAccrs)}, and ${JSON.stringify(resultExistingYears)}.\n`;
      fs.appendFile(`./logs/descriptorenrichment.log`, `[${now.toUTCString()}] : ${shoutout}\n`, 'utf-8');

      // prepare the new edge now that we have done enrichments
      let newEdge = [];
      newEdge[0] = result['hash'];     // [Source:string]
      newEdge[1] = row['Id'];          // [Target:string] this value is the id for the name of the article
      newEdge[2] = 1;                  // [Weight:integer]
      newEdge[3] = "Directed";         // [Type:string]
      newEdge[4] = "descriptor";       // [Kind:string]
      newEdge[5] = row['Label'];       // [ArticleTitle:string]
      newEdge[6] = row['Year'];        // [Year:integer]
      newEdge[7] = row['JournalAccr']; // [JournalAccr:string]
    
      /* === Modification stages === */
      // The case when the year and the JournalAccr are missing from their coresponding arrays of the descriptor
      if (!resultExistingYears.includes(row['Year'] && !resultExistingJournalAccrs.includes(row['JournalAccr']))) {        
        // if the `Year` value in the row (of the `descriptors` table) doesn't exist
        let queryStringForAmmendYearsArray = `
          UPDATE descriptors 
          SET 
            Years = json_set(Years, '$.values', ?), 
            JournalAccrs = json_set(JournalAccrs, '$.values', ?)
          WHERE hash = ?
        `;
    
        db.run(queryStringForAmmendYearsArray, [JSON.stringify(resultExistingYears), JSON.stringify(resultExistingJournalAccrs), result['hash']], async function clbkUpdateTwoVals (error) {
          if (error) {
            throw new Error (`By the moment I tried to update the two values, this error appeared ${error.message}`);
          }
          // create a new edge for this case when the descriptor shows up at another year, another journal/conference (venue)
          if (newEdge.length === 8) {
            await createAnEdge(newEdge);
          }
          // Log the success message
          console.log(`${this.changes} enrichment for descriptor: ${result['descriptor']}`);
        });
      } else if (!resultExistingYears.includes(row['Year'])) {
        // treat the case when only the value or the `Year` is different
        addOneValueToAJSONarr('descriptors', 'Years', 'values', JSON.stringify(resultExistingYears));
        // create a new edge for the case when a descriptor shows up in another year
        if (newEdge.length === 8) {
          await createAnEdge(newEdge);
        }
      } else if (!resultExistingJournalAccrs.includes(row['JournalAccr'])) {
        // treat the case when the accronim of the venue doesn't exist
        addOneValueToAJSONarr('descriptors', 'JournalAccrs', 'values', JSON.stringify(resultExistingJournalAccrs));
        // treat the case when the descriptor shows up at the same year but to another article at another venue
        if (newEdge.length === 8) {
          await createAnEdge(newEdge);
        }
      }
    });
  };

  // db.close(); // in the end close connection with the database
} catch (error) {
  console.log(error);
  let now = new Date();
  let logline = `[${now.toUTCString()}] «Error»: ${error.message}`;
  fs.appendFile(`./logs/error.log`, `${logline}\n`, 'utf8');
}

