import fs from 'node:fs/promises';
import { parse } from 'csv-parse';
import inquirer from 'inquirer';
import {connectToDatabase} from './db.js';
import test4empty from './util/empty.js';
import {inspect} from 'util';

let dbFileName = `publications.sqlite`;
let db = await connectToDatabase(dbFileName); // connect to the database

let crypto;
try {
  crypto = await import('node:crypto');
} catch (err) {
  console.error('crypto support is disabled!');
} 

// preparing for a possible interface

/* === PRIMARY SETTING UP for `articles` table (considered the primary node table) === */
// for this scenario, the nodes are the titles of the articles and their corresponding ids are generated by Zotero at export time as CSV
let nodesTabelHeadStructure = `Id,Label,` + `Year,Author,JournalAccr,Kw`; // Mind that the `Id` and `Label` should be strict as such. The rest of the atributes may be of your own choosing
let nodesIdxsAreArrays = [2, 5]; // The values at these indexes are actualy arrays
let nodesTableRecordMarcherIdxs = [0, 3, 1, 2, 4, 5]; // These are the indexes of every value in an array representing a line from the CSV. This is useful when you want some other entity as node value (`Label`)
let nodesTableValPlaceholders   = `?, ?, ?, json(?), ?, json(?)`; // the number of the question marks should match the number of the values in the head (`nodesTabelHeadStructure`). The coding as JSON is essential for quering.
let mainTablename = `articles`;
// the query needed to create `articles` table
let tableExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='${mainTablename}'`;
// QUERY needed for creating the table
let tblCreateQuery = `
CREATE TABLE articles
(
  Id           VARCHAR(10),
  Label        VARCHAR(250),
  Year         INTEGER,
  Author       json,
  JournalAccr  VARCHAR(20),
  Kw           json,
)
`;

/* === Descriptors table === */
let descriptorsExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='descriptors'`;
let descriptorsTabelHeadStructure = `hash,descriptor,Years,JournalAccrs`;
let descriptorsTableValPlaceholders   = `?, ?, json(?), json(?)`;
let tblDescriptorsCreateQuery = `
CREATE TABLE IF NOT EXISTS descriptors (
  id           INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
  hash         VARCHAR(50),
  descriptor   VARCHAR(250),
  Years        json,
  JournalAccrs json
)
`;
// create `descriptors` table if it doesn't exists already
db.get(descriptorsExistsQuery, async function clbkDesrsTblExists (error, count) {
  if (error) {
    throw new Error(`I've looked for the table descriptors, but this error appeared ${error.message}`, error);
  } else if (count['result'] === 0) {
    db.run(tblDescriptorsCreateQuery);
  } else if (count['result'] === 1) {
    console.log(`Table descriptors already exists, jolly lassie!`);
  }
});

/* === Edges table === */
let edgesExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='edges'`;
let edgesTabelHeadStructure = `Source,Target,Weight,Type,Kind,Article,Year,JournalAccr`;
let edgesTableValPlaceholders = `?, ?, ?, ?, ?, ?, ?, ?`;
let tblEdgesCreateQuery = `
CREATE TABLE IF NOT EXISTS edges (
  id           INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
  Source       VARCHAR(50),
  Target       VARCHAR(50),
  Weight       INTEGER,
  Type         VARCHAR(20),
  Kind         VARCHAR(20),
  Article      VARCHAR(300),
  Year         INTEGER,
  JournalAccr  VARCHAR(20)
)
`;// [Source] the id of the concept [Target] the id of the article [Weight:integer] 1 [Type:string] Directed [Kind:string] descriptor [Year:integer] 2002 (the year when the article was published) [JournalAccr:string] DL'09

// create `edges` table if it doesn't exists already
db.get(edgesExistsQuery, async function clbkTblEdgesExists (error, count) {
  if (error) {
    throw new Error(`I've looked for the table edges, but this error appeared ${error}`);
  }  else if (count['result'] === 0) {
    db.run(tblEdgesCreateQuery);
  } else if (count['result'] === 1) {
    console.log(`Table edges already exists, silly bat!`);
  }
});

/**
 *The function is populating the `articles` table with the data 
 *from the source file
 */
async function populateTable () {
  // read the file source
  const fd = await fs.open("./sourcefile/data-prima-forma.csv");
  fd.createReadStream()
      .pipe(parse({ delimiter: ",", from_line: 2 }))
      .on("data", function clbkWorkOnRow(row) {
        // console.log(`Valorile rândului sunt ${row[0]}, apoi ${row[1]}`);

        // prepare and load the data
        let prepStmt = db.prepare(`INSERT INTO articles(${nodesTabelHeadStructure}) VALUES (${nodesTableValPlaceholders})`);
        // prepStmt.run([row[0],row[3],row[1],row[2],row[4],row[5]], function clbkerrorinsert(error) {
        prepStmt.run(nodesTableRecordMarcherIdxs.map((idx) => {
          // set JSON value
          if (nodesIdxsAreArrays.includes(idx)) {            
            let valuesArr = {
              values: row[idx].split('; ')
            };
            if (valuesArr['values'].length > 0) {
              // console.log(`The values when we have actualy an array ${JSON.stringify(valuesArr)}`); // {"values":["Silva, Paulo","Matos, Miguel","Barreto, João"]}
              return `${JSON.stringify(valuesArr)}`;
            } else {
              console.log(`I have one value here ${row[idx]}`);
              return `{"values":[${row[idx]}]}`;
            }

          } else {
            return row[idx];
          }
        }), function clbkerrorinsert(error) {
          if (error) {
            throw new Error(`At inserting the data, this error appeared: ${error.message}`);
          } else {
            console.log(`Inserted row: ${this.lastID}`);
          }
        });
        prepStmt.finalize();

        // check if all was loaded OK
        // db.each("SELECT rowid AS id, title FROM articles", function(err, row) {
        //   console.log(row.id + ": " + row.title);
        // });
      })
      .on("end", function () {
          console.log("finished");
      })
      .on("error", function (error) {
          console.log(error.message);
      }); 
}

try {
  /*
  * === SETTING UP THE DATABASE ===
  * Investigate if the table exists. If it exists, ask user if she/he wants to wipe clean the data.
  * If it doesn't exists, create the table
  * The user can opt for cleaning the table and repopulating with fresh data from the source.
  * As soon as the data was wipped, the table will be repopulated with the data from the source.
  */
  db.get(tableExistsQuery, async function clbkTableExists (error, count) {
    if (error) {
      throw new Error(`I've looked for the table, but this error appeared ${error}`);
    } else if (count['result'] === 1) {
      console.log(`Table articles already exists, silly ol' chap!`);

      // put an option to cleaning the existing data (https://betterprogramming.pub/how-to-create-beautiful-command-line-interactions-with-node-js-2fcdfbbac62c)
      inquirer.prompt([
        {
          type: 'checkbox',
          name: 'wipearticles',
          message: 'Would you like me to clean the data of the articles table?',
          default: 'no',
          choices: [
            {name: 'no'},
            {name: 'yes', checked: false},
          ],
        }
      ]).then(async function getMeAnswers (answers) {
        let chain = [
          `DELETE FROM ${mainTablename}`,
          `DELETE FROM descriptors`,
          `DELETE FROM edges`
        ];
        // if you want to clean the data from the table, you must have an `yes` value for an answer 
        if (answers.wipearticles == 'yes') {
      
          for (let query of chain) {
            db.run(query, function clbkChainTrigger (error) {
              if (error) {
                throw new Error (`Wipping table data raised this error: ${error}`);
              } else {
                console.log(`I've wipped clean the data from the tables`);
              }
            });
          }
          await populateTable();
        }
      }).catch((error) => {
        if (error.isTtyError) {
          throw new Error (`Prompt couldn't be rendered in the current environment`);
        } else {
          throw new Error (`When cleaning descriptors table the following error was raised: ${error}`);
        }      
      });
    } else {
      db.exec(tblCreateQuery);
      await populateTable();
    }
  });

  /*
  * Case study:
  * I want every piece of a keyword list to become an entity with an id (md5 generated)
  * 
  * #1 Create a table `concepts` where new records are the individual keywords from the article records
  *  - Create a function which adds a record as long as the `Label` was not already inserted
  *  - The record should look like: `[Id]CD4GRTT [Label]machine learning
  * #2 Create a table of `edges` where the the following conditions are met in the following workflow:
  *  - take one record from the `concepts` table and look up for all the records from the `articles` table where it appears in the `kw` field.
  *  - if it is matched, create a record in the table `edges` where you have te following fields: 
  *   - [Source] the id of the concept [Target] the id of the article [Weight:integer] 1 [Type:string] Directed [Kind:string] descriptor [Year:integer] 2002 (the year when the article was published) [JournalAccr:string] DL'09
  */

  /**
   * Function creates a new record in the `edges` table
   */
  async function createAnEdge (recordArray) {
    // console.log(`I'm ready to insert the following edge: ${recordArray}`);
    db.get(`SELECT * FROM edges WHERE Source="${recordArray[0]}" AND Target="${recordArray[1]}"`, function clbkCheck4Existing (edge) {
      if (test4empty(edge)) {
        // #A Prepare the statement
        let prepStmt = db.prepare(`INSERT INTO edges(${edgesTabelHeadStructure}) VALUES (${edgesTableValPlaceholders})`);

        // #B run the query
        prepStmt.run(recordArray, function clbkInsertEdge (error) {
          if (error) {
            throw new Error(`Inserting an edge, this error appeared: ${error.message}`);
          } else {
            console.log(`Inserted edge no: ${this.lastID}`);
          }
        });

        // #C Finalize!
        prepStmt.finalize();
      } else {
        return console.log(`The edge exists already, I will not created again. Move along, nothing to see here!`);
      }
    });
  };

  /**
   * The function adds one value to an array existing in a JSON value of a cel in a particular table
   * @param {*} tableName 
   * @param {*} columName 
   * @param {*} keyName 
   * @param {JSON} value 
   */
  function addOneValueToAJSONarr (tableName, columName, keyName, value, hash) {
    let query = `
      UPDATE ${tableName}
      SET ${columName} = json_set(${columName}, '$.${keyName}', ?)
      WHERE hash = ?;
    `;
    db.run(query, [value, hash], function clbkUpdateOneArr (error) {
      if (error) {
        throw new Error (`At the moment of updating the value, the following error popped up: ${error.message}`);
      }
      console.log(`${this.changes} enrichment for descriptor: ${hash}`);
    });
  }

  let clearing = new Set(); // clearing house for the descriptors
  /**
   * Function pushes descriptors in `descriptors` table
   * It also pushes the first edge in the edge table
   * There are 20253 descriptors even when they double (10877 unique descriptors)
   */
  async function addUniqueDescriptorToTable (descriptor, row) {
    // console.log(`The descriptor is ${descriptor} and is in the clearing ${clearing.has(descriptor)}`);
    if (!clearing.has(descriptor) && !test4empty(descriptor)) {
      clearing.add(descriptor);
      // #A prepare and load the data
      let prepStmt = db.prepare(`INSERT INTO descriptors(${descriptorsTabelHeadStructure}) VALUES (${descriptorsTableValPlaceholders})`);
      let descriptorsRowIdxsReordered = []; // the array of the values bound to be inserted into the table

      // create the hash
      const hash = crypto.createHash('sha256');
      hash.update(descriptor);

      descriptorsRowIdxsReordered[0] = hash.digest('hex'); // the value for `hash` column
      descriptorsRowIdxsReordered[1] = descriptor;  // the value for `descriptor` column
      descriptorsRowIdxsReordered[2] = `${JSON.stringify({values: [row['Year']]})}`; // the value for `Year` column
      descriptorsRowIdxsReordered[3] = `${JSON.stringify({values: [row['JournalAccr']]})}`; // the value for `JournalAccr` column

      // #B run the query
      prepStmt.run(descriptorsRowIdxsReordered, function clbkerrorinsert(error) {
        if (error) {
          throw new Error(`At inserting the data in the descriptors table, this error appeared: ${error.message}`);
        }
        console.log(`Processing descriptor: ${this.lastID}`);
      });

      // #C Finalize!
      prepStmt.finalize();

      // Create all the edges here and insert it in the edges table
      let edge = [];
      edge[0] = descriptorsRowIdxsReordered[0]; // [Source:string]
      edge[1] = row['Id']; // [Target:string] this value is the id for the name of the article
      edge[2] = 1; // [Weight:integer]
      edge[3] = "Directed"; // [Type:string]
      edge[4] = "descriptor"; // [Kind:string]
      edge[5] = row['Label']; // [ArticleTitle:string]
      edge[6] = row['Year']; // [Year:integer]
      edge[7] = row['JournalAccr']; // [JournalAccr:string]

      if (edge.length === 8) {
        await createAnEdge(edge);
      }

      let TrackerObj = {
        descriptor,
        hash: descriptorsRowIdxsReordered[0],
        origin: row
      };

      // fs.writeFile('./tracker.json', `${JSON.stringify(TrackerObj , null, 2)},`, 'utf8');
    }
  }

  /**
   * Function will enrich all the records in the descriptors table
   * It will add years for the same descriptor where this one shows up for the articles
   * It will create edges in certain cases
   * @param {Object} row 
   */
  function enrichDescriptorNodes (row) {  
      let KwObj = JSON.parse(row['Kw']); // parse the object value in in Kw
      let kwArr = KwObj['values'];       // set `kwArr` -> should be an array
      // console.log(`The descriptor array for this row is ${kwArr}`);

      for (let descriptor of kwArr) {
        db.get(`SELECT * FROM descriptors WHERE descriptor="${descriptor}"`, async function clbkChec4ExistanceOfDescr (error, result) {
          if (error) {
            throw new Error (`Searching for the same descriptor, I came upon this error: ${error.message}`, error);
          }
          if (!test4empty(result)) {
            
            // Extract the year and compare with the values already existing
            let yearsParsed = JSON.parse(result['Years']);  // transform the JSON text into an object
            let resultExistingYears = yearsParsed['values'];// extract the array
            // first test if there is an array of years
            if (Array.isArray(resultExistingYears)) {
              if (row['Year'] !== undefined && !resultExistingYears.includes(row['Year'])) {
                resultExistingYears.push(row['Year']);
              }; // update the years to include the new year as well
            } else {
              let shout4years = `For the existing descriptor with id <${result.descriptor}>, value of Years was ${result['Years']}, transformed into ${yearsParsed}.\n`;
              // For the existing descriptor with id digital cultural heritage, value of Years was {"values":"{\"values\":[2012,2023]}"}, that cnnot be transformed into an array. I've created one 
              console.log(shout4years);
              fs.appendFile('./descriptorenrichment.txt', shout4years, 'utf-8');
              throw new Error (`There is something fishy with this tranformation. I expected an array and came about this ${resultExistingYears}`);
            }


            let JournalAccrs = JSON.parse(result['JournalAccrs']);  // transform the JSON text into an object
            let resultExistingJournalAccrs = JournalAccrs['values'];// extract the array
            // first test id there is an aray of values
            if (Array.isArray(resultExistingJournalAccrs)) {
              if (row['JournalAccr'] !== undefined && !resultExistingJournalAccrs.includes(row['JournalAccr'])) {
                resultExistingJournalAccrs.push(row['JournalAccr'])
              }; // update de Accrs to include the new journal accr as well
            } else {
              let shout4accrs = `For the existing descriptor with id <${result.descriptor}>, value of JournalAccrs was ${result['JournalAccrs']}, transformed into ${JournalAccrs}.\n`;
              console.log(shout4accrs);
              fs.appendFile('./descriptorenrichment.txt', shout4accrs, 'utf-8');
              throw new Error (`There is something fishy with this tranformation. I expected an array and came about this ${resultExistingJournalAccrs}`);
            }

            // prepare the new edge
            let newEdge = [];
            newEdge[0] = result['hash'];     // [Source:string]
            newEdge[1] = row['Id'];          // [Target:string] this value is the id for the name of the article
            newEdge[2] = 1;                  // [Weight:integer]
            newEdge[3] = "Directed";         // [Type:string]
            newEdge[4] = "descriptor";       // [Kind:string]
            newEdge[5] = row['Label'];       // [ArticleTitle:string]
            newEdge[6] = row['Year'];        // [Year:integer]
            newEdge[7] = row['JournalAccr']; // [JournalAccr:string]
          
            // The case when the year and the JournalAccr are missing from their coresponding arrays of the descriptor
            if (!resultExistingYears.includes(row['Year'] && !resultExistingJournalAccrs.includes(row['JournalAccr']))) {
          
              // if the `Year` value in the row (of the `descriptors` table) doesn't exist
              let queryStringForAmmendYearsArray = `
                UPDATE descriptors 
                SET 
                  Years = json_set(Years, '$.values', ?), 
                  JournalAccrs = json_set(JournalAccrs, '$.values', ?)
                WHERE hash = ?
              `;
          
              db.run(queryStringForAmmendYearsArray, [JSON.stringify({values: resultExistingYears}), JSON.stringify({values: resultExistingJournalAccrs}), result['hash']], async function clbkUpdateTwoVals (error) {
                if (error) {
                  throw new Error (`By the moment I tried to update the two values, this error appeared ${error.message}`);
                }
                // create a new edge for this case when the descriptor shows up at another year, another journal/conference (venue)
                if (newEdge.length === 8) {
                  await createAnEdge(newEdge);
                }
                // Log the success message
                console.log(`${this.changes} enrichment for descriptor: ${result['descriptor']}`);
              });
            } else if (!resultExistingYears.includes(row['Year'])) {
              // treat the case when only the value or the `Year` is different
              addOneValueToAJSONarr('descriptors', 'Years', 'values', JSON.stringify({values: resultExistingYears}));
              // create a new edge for the case when a descriptor shows up in another year
              if (newEdge.length === 8) {
                await createAnEdge(newEdge);
              }
            } else if (!resultExistingJournalAccrs.includes(row['JournalAccr'])) {
              // treat the case when the accronim of the venue doesn't exist
              addOneValueToAJSONarr('descriptors', 'JournalAccrs', 'values', JSON.stringify({values: resultExistingJournalAccrs}));
              // treat the case when the descriptor shows up at the same year but to another article at another venue
              if (newEdge.length === 8) {
                await createAnEdge(newEdge);
              }
            }        
          
            // #1 Search the record
            /*          
            SELECT *
            FROM articles
            WHERE id IN (
              SELECT Id
              FROM articles
              WHERE json_extract(Kw, '$.values') LIKE '%"digital libraries"%'
            );          
            */ 
          }        
        });        
      }
      return `Done!`;
  };

  /**
   * Function checks is the descriptor exists already, and if it does, 
   * checks if the other attributes are already in the columns meant 
   * to gather it (year[array] and the journal accronim[array])
   * Criteria: `SELECT DISTINCT descriptor FROM descriptors WHERE descriptor="${descriptor}"` 
   * @param {String} descriptor 
   */
  async function descriptorAndEdgeCreator (row) {
    let KwObj = JSON.parse(row['Kw']); // parse the object value in in Kw
    let kwArr = KwObj['values'];       // set `kwArr` -> should be an array
    // console.log(`The descriptor array for this row is ${kwArr}`);

    for (let descriptor of kwArr) {
      addUniqueDescriptorToTable(descriptor, row);
    }
  };

  /**
   * Function generates al the possible pairing between certain identifiers
   * Helper function for `createArticleToArticleEdge` function
   * @param {Array} arr 
   * @returns {Array} combinations
   */
  function* generateDistinctPairs(array) {
    for (let i = 0; i < array.length; i++) {
      for (let j = i + 1; j < array.length; j++) {
        yield [array[i], array[j]];
      }
    }
  };

  /**
   * Function creates all possible edges having for source and target article identifiers.
   * It is the callback for the foreach in the `articlesGraphCreator` function
   * Receives as value of the parameter one whole row from descriptor's table 
   * @param {Object} descriptorRecord 
   */
  async function createArticleToArticleEdge (descriptorRecord) {
    // console.log(`${inspect(descriptorRecord['hash'])}`);    
    // use the hash to search for all the records in the entities table
    if (descriptorRecord['hash']) {
      // console.log(`${descriptorRecord['hash']}`);
      db.all(`SELECT * FROM edges WHERE Source="${descriptorRecord['hash']}"`, async (error, records) => {
        if (error) {
          throw new Error (`Something happened when I tried to fetch the data: ${error}`);
        }
        // console.log(records);
        let articlesIds = records.map(rec => rec['Target']);

        // console.log(`The Ids I need are  ${JSON.stringify(articlesIds)}`);
        if (articlesIds.length >= 2) {
          // console.log(`This segment has ${articlesIds.length} Ids`);
          // if (articlesIds.length > 5) {
          //   console.log(`Better check this one out ${JSON.stringify(articlesIds)} for the ${descriptorRecord['hash']}\n`);
          //   fs.appendFile('./biggerthan5.csv', `${JSON.stringify(articlesIds)} for the ${descriptorRecord['hash']}\n`, 'utf8');
          // }
          
          
          // You better have at least 8 cores for this :)))) MUHHAHAHAHAHAHAHA!
          let newEdges = generateDistinctPairs(articlesIds); // gives you all the possible combinations

          // FIXME: Hmmmmm... find another way
          // for (let combo of newEdges) {
          //   // let sourceRowData = await getRecordsFromTable(articles, Id, combo[0]);
          //   // let targetRowData = await getRecordsFromTable(articles, Id, combo[1]);
          //   db.each(`SELECT * FROM 'articles' WHERE 'Id'="${combo[0]}"`, (error, combo0Rec) => {
          //     if (error) {
          //       throw new Error (`An error has been issued when accessing the articles table trying to get data for the article in the <Source> position: ${error}`);
          //     }
          //     // data for the article in the `Source` position
          
          //     // And down to the pyramid of dooooooommmmmm! Save me Obi Wan! You are my only hope!
          //     db.each(`SELECT * FROM 'articles' WHERE 'Id'="${combo[1]}"`, async (error, combo1Rec) => {
          //       if (error) {
          //         throw new Error (`An error has been issued when accessing the articles table trying to get data for the article in the <Target> position: ${error}`);
          //       }
          //       // data for the article in the `Target` position
          //       let newArticleEdge = [...combo, 1, "Undirected", descriptorRecord['descriptor'], " ", `${combo0Rec['Year']},${combo1Rec['Year']}`,  `${combo0Rec['JournalAccr']},${combo1Rec['JournalAccr']}`];
          //       console.log(`The inbound edge: ${newArticleEdge}`);
          //       let line = newArticleEdge.join('","') + '\n';
          //       if (newArticleEdge.length === 8) {
          //         fs.appendFile('./articledges.csv', line, 'utf8');
          //         // await createAnEdge(newArticleEdge);
          //       }
          //     });  
          //   });
          // }




        }
      });
    }
  }

  /**
   * Function is creating edges for every articles that are linked through a common descriptor
   * The descriptor is treated as a verb (name of the edge)
   * @param {*} row The row of data for an article who's keywords are being processed
   */
  function articlesGraphCreator (row) {
    let KwObj = JSON.parse(row['Kw']); // parse the object value in in Kw
    let kwArr = KwObj['values'];       // set `kwArr` -> should be an array
    // console.log(`The descriptor array for this row is ${JSON.stringify(kwArr)}`);

    for (let descriptor of kwArr) {
      db.each(`SELECT * FROM descriptors WHERE descriptor="${descriptor}"`, function clbkDescrPaitToArts (error, descrData) {
        if (error) {
          throw new Error (`Selecting all data from the table descriptors, this error was thrown: ${error}`);
        }        
        // console.log(`${inspect(descrData)}`);
        createArticleToArticleEdge(descrData);
      });
    }
  }

  // Parse all data from articles table and build descriptor and edges tables
  db.all(`SELECT * FROM articles`, function clbkparseDataOneTbl (error, rows) {
    if (error) {
      throw new Error (`Selecting all data from the table articles, this error was thrown: ${error}`);
    }

    /* === create the unique descriptors in their table === */
    rows.forEach(async function clbkForEveryRow (row) {
      if (test4empty(row)) {
        throw new Error(`It seems I found an empty row: ${error}`);
      }
      // in case the keywords array value doesn't come empty
      if (!test4empty(row['Kw'])) {
        await descriptorAndEdgeCreator(row); 
      }
    });

    /* === enrich with data the descriptor on second passing === */
    rows.forEach(function clbkEnrich4EveryRow (row) {
      if (test4empty(row)) {
        throw new Error(`It seems I found an empty row: ${error}`);
      }
      enrichDescriptorNodes(row);
    });

    /* === Create edges between articles === FIXME: Do not acivate this until fixed*/
    // rows.forEach(function clbkEnrich4EveryRow (row) {
    //   if (test4empty(row)) {
    //     throw new Error(`It seems I found an empty row: ${error}`);
    //   }
    //   articlesGraphCreator(row);
    // });
  });

/*

Given two rows in an Sqlite3 table containing a column where cell value is a JSON:
- create an Sqlite3 query that searches a value existing as element of an array in the JSON if it exists in other rows in the same column
- create a subset with those rows.


SELECT *
FROM articles
WHERE json_extract(Kw, '$.values') LIKE '%"digital libraries"%';
*/ 

  db.close(); // in the end close connection with the database
} catch (error) {
  console.log(error);
}

