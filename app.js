import fs from 'node:fs/promises';
import { finished } from 'stream/promises';
import { parse } from 'csv-parse';
import inquirer from 'inquirer';
// import {connectToDatabase} from './db.js'; // https://github.com/kriasoft/node-sqlite
// import * as connection from './db.js'; // https://github.com/kriasoft/node-sqlite
import test4empty from './util/empty.js';
import {inspect} from 'util';

let crypto;
try {
    crypto = await import('node:crypto');
} catch (err) {
    console.error('crypto support is disabled!');
} 

// connect to database
import sqlite3 from 'sqlite3';
sqlite3.verbose();
import { open } from 'sqlite'

(async function app () {
  try {
    let sourcefilename = `./sourcefile/data-adoua-forma.csv`;

    const db = await open({
      filename: '/home/nicolaie/Desktop/DEVELOPMENT/GnodEdge/publications.sqlite',
      driver: sqlite3.cached.Database
    })

    /* === PRIMARY SETTING UP for `articles` table (considered the primary node table) === */
    // for this scenario, the nodes are the titles of the articles and their corresponding ids are generated by Zotero at export time as CSV
    let nodesTabelHeadStructure = `Id,Label,` + `Year,Author,JournalAccr,Kw`; // Mind that the `Id` and `Label` should be strict as such. The rest of the atributes may be of your own choosing
    let nodesIdxsAreArrays = [2, 5]; // The values at these indexes are actualy arrays
    let nodesTableRecordMarcherIdxs = [0, 3, 1, 2, 4, 5]; // These are the indexes of every value in an array representing a line from the CSV. This is useful when you want some other entity as node value (`Label`)
    let nodesTableValPlaceholders   = `?, ?, ?, json(?), ?, json(?)`; // the number of the question marks should match the number of the values in the head (`nodesTabelHeadStructure`). The coding as JSON is essential for quering.
    let mainTablename = `articles`;
    // the query needed to create `articles` table
    let tableExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='${mainTablename}'`;
    // QUERY needed for creating the table
    let tblCreateQuery = `
    CREATE TABLE IF NOT EXISTS articles (
        Id           VARCHAR(10),
        Label        VARCHAR(250),
        Year         INTEGER,
        Author       json,
        JournalAccr  VARCHAR(20),
        Kw           json
    )
    `;
    /* === Descriptors table === */
    let descriptorsExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='descriptors'`;
    let descriptorsTabelHeadStructure = `hash,descriptor,Years,JournalAccrs`;
    let descriptorsTableValPlaceholders   = `?, ?, json(?), json(?)`;
    let descriptorsTblName = 'descriptors';
    let tblDescriptorsExists = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='${descriptorsTblName}'`;
    let tblDescriptorsCreateQuery = `
    CREATE TABLE IF NOT EXISTS descriptors (
        id           INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
        hash         VARCHAR(50),
        descriptor   VARCHAR(250),
        Years        json,
        JournalAccrs json
    )
    `;
    /* === Edges table === */
    let edgesExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='edges'`;
    let edgesTabelHeadStructure = `Source,Target,Weight,Type,Kind,Article,Year,JournalAccr`;
    let edgesTableValPlaceholders = `?, ?, ?, ?, ?, ?, ?, ?`;
    let edgesTblName = 'edges';
    let tblEdgesExists = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='${edgesTblName}'`;
    let tblEdgesCreateQuery = `
    CREATE TABLE IF NOT EXISTS edges (
        id           INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
        Source       VARCHAR(50),
        Target       VARCHAR(50),
        Weight       INTEGER,
        Type         VARCHAR(20),
        Kind         VARCHAR(20),
        Article      VARCHAR(300),
        Year         INTEGER,
        JournalAccr  VARCHAR(20)
    )
    `;

    // let articlesExists = db.get(tableExistsQuery, (e, r) => {
    //   if (e) console.error;
    //   // console.log(r)
    // });

    // let a = await db.get(`SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='articles'`);
    // const result = await db.get('SELECT Label FROM articles WHERE Label = ?', 'Growth and Server Availability of the NCSTRL Digital Library');
    // console.log(a);

    let articlesExists = await db.get(tableExistsQuery);
    let descriptorsExists = await db.get(tblDescriptorsExists);
    let edgesExists = await db.get(tblEdgesExists);

    if (articlesExists.result === 1) {
      console.log(`The table articles already exists, ol' chap!`);
    } else {
      await db.exec(tblCreateQuery);
    }

    if (descriptorsExists.result === 1) {
      console.log(`Table descriptors already exists, jolly lassie!`);
    } else {
      await db.exec(tblDescriptorsCreateQuery);
    }

    if (edgesExists.result === 1) {
      console.log(`Table edges already exists, silly bat!`);
    } else {
      await db.exec(tblEdgesCreateQuery);
    }

    let x = await Promise.all([db.get(tableExistsQuery), db.get(tblDescriptorsExists), db.get(tblEdgesExists)]);
    let tablesOK = x.every((element) => {
      return element.result === 1;
    })

    if (tablesOK) {
      let noTblArticles = await db.get(`SELECT count(*) as artNrs FROM articles`);
      if (!noTblArticles.artNrs > 0) {
        await populateArticlesTable();
      } else {
        await stagesProcessing();
      }
    }
    /**
     * Function is a callback for `on("data", clbkWorkOnRow)`
     * This is the place whre table articles gets hidrated
     *  with data from the chunk
     * @param {Object} row 
     */
    async function processDataRow(row) {
      try {
        // prepare an Sqlite3 statement and load the data
        let stmt = await db.prepare(`INSERT INTO articles(${nodesTabelHeadStructure}) VALUES (${nodesTableValPlaceholders})`);
        // Insert into the articles the data
        await stmt.bind(nodesTableRecordMarcherIdxs.map((idx) => {
          // set JSON value
          let now = new Date();
          if (nodesIdxsAreArrays.includes(idx)) {            
            let valuesArr = {
              values: row[idx].split('; ')
            };
            if (valuesArr['values'].length > 0) {
              // console.log(`The values when we have actualy an array ${JSON.stringify(valuesArr)}`); // {"values":["Silva, Paulo","Matos, Miguel","Barreto, João"]}
              return `${JSON.stringify(valuesArr)}`;
            } else {
              // console.log(`I have one value here ${row[idx]}`);            
              let logline = `[${now.toUTCString()}] «clbkWorkOnRow(row)»: I have inserted in article table: ${row[idx]}.\n`;
              fs.appendFile(`./logs/main.log`, `${logline}`, 'utf8');
              return `{"values":[${row[idx]}]}`;
            }  
          } else {
            let logline = `[${now.toUTCString()}] «clbkWorkOnRow(row)»: I have inserted in article table: ${row[idx]}.\n`;
            fs.appendFile(`./logs/main.log`, logline, 'utf8');
            return row[idx];
          }
        }));
        let result = await stmt.get();
      } catch (error) {
        throw new Error(error);
      }
    };

    /**
     *The function is populating the `articles` table with the data 
    *from the source file
    */
    async function populateArticlesTable () {
      try {
      // read the file source
      const fd = await fs.open(sourcefilename);
      fd.createReadStream()
          .pipe(parse({ delimiter: ",", from_line: 2, skip_empty_lines: true, trim: true }))
          .on("data", async function clbkWorkOnRow(row) {
            await processDataRow(row);
          })
          .on("end", function () {
              console.log(`I've finished reading the CSV. Data is still being writen in the table`);
          })
          .on("error", function (error) {
              console.log(error.message);
          });
      } catch (error) {
        throw new Error (error);
      }
    };

    /**
     * The function will process the rest of the steps:
     * creating data in descriptors and building edges
     * Calls `populateArticlesTable()`
     * Calls `descriptorAndEdgeCreator(row)`
     * Calls `enrichDescriptors()`
     */
    async function stagesProcessing () {
      try {
        let articlesRows = await db.each(`SELECT * FROM articles`, async function clbkparseDataOneTbl (error, row) {
          if (error) {
            throw new Error (`Selecting all data from the table articles, this error was thrown: ${error}`);
          }
          // in case the keywords array value doesn't come empty
          if (!test4empty(row['Kw'])) {
            await descriptorAndEdgeCreator(row); 
          }
        }); // the `articlesRows` must be of value 4778
        console.log(`The number of records is ${JSON.stringify(articlesRows)}`);

        await enrichDescriptors();
      } catch (error) {
        throw new Error (`From stagesProcessing() : ${error}`);
      }
    };

    /* === THE HELPER FUNCTIONS === */

    /**
     * Function creates a new record in the `edges` table
     * @param {Array} recordArray 
     */
    async function createAnEdge (recordArray) {
      // console.log(`I'm ready to insert the following edge: ${recordArray}`);
      try {
        let edgesSearched = await db.get(`SELECT * FROM edges WHERE Source="?" AND Target="?"`, [recordArray[0], recordArray[1]]);

        for (let edge of edgesSearched) {
          // the edge doesn't exist, so create one
          if (edge === undefined) {
            // #A Prepare the statement
            let stmt = await db.prepare(`INSERT INTO edges(${edgesTabelHeadStructure}) VALUES (${edgesTableValPlaceholders})`);
    
            // #B run the query
            await stmt.bind(recordArray);
    
            // #C Finalize!
            let result = await stmt.get();
          } else {
            return console.log(`The edge exists already, I will not created again. Move along, nothing to see here!`);
          }
        }     
      } catch (error) {
        throw new Error(error);
      }
    };

    /**
     * The function adds one value to an array existing in 
     * a JSON value of a cell in a particular table
     * @param {*} tableName 
     * @param {*} columName 
     * @param {*} keyName 
     * @param {JSON} value 
     */
    async function addOneValueToAJSONarr (tableName, columName, keyName, value, hash) {
      let query = `
        UPDATE ${tableName}
        SET ${columName} = json_set(${columName}, '$.${keyName}', ?)
        WHERE hash = ?;
      `;
      let targetModified = await db.run(query, [value, hash]);

      if (targetModified.changes === 1) {
        console.log(`${this.changes} enrichment for descriptor: ${hash}`);
      }
    }

    
    /**
     * Function pushes descriptors in `descriptors` table.
     * It also pushes the first edge in the edge table.
     * It checks is the descriptor exists already, and if it does, 
     * It checks if the other attributes are already in the columns meant to gather it: 
     *  - (year[array] and the journal accronim[array])
     * Criteria: `SELECT DISTINCT descriptor FROM descriptors WHERE descriptor="${descriptor}"` 
     * Calls `createAnEdge(edge)`
     * @param {String} descriptor 
     */
    async function descriptorAndEdgeCreator (row) {
      try {
        let clearing = new Set(); // clearing house for the descriptors
        let KwObj = JSON.parse(row['Kw']); // parse the object value in in Kw
        let kwArr = KwObj['values'];       // set `kwArr` -> should be an array
        // console.log(`The descriptor array for this row is ${kwArr}`);
    
        for (let descriptor of kwArr) {
          console.log(`The descriptor is ${descriptor} and is in the clearing ${clearing.has(descriptor)}`);
          if (!clearing.has(descriptor) && !test4empty(descriptor)) {
            clearing.add(descriptor);
    
            // first search if there is a already the same descriptor inserted in the table
            let allDescriptorsOfName = await db.get(`SELECT * FROM descriptors WHERE descriptor="${descriptor}"`);

            console.log(`The value for the descriptor I get is ${JSON.stringify(allDescriptorsOfName)}`);
            
            if (allDescriptorsOfName !== undefined && descriptor == allDescriptorsOfName.descriptor) {
              console.log(`I will not write another one because I found it already. Look: ${allDescriptorsOfName.descriptor}. If you need to write fresh descriptors table, just delete it first.`);
              return;
            } else {
              // #A prepare and load the data
              let stmt = await db.prepare(`INSERT INTO descriptors(${descriptorsTabelHeadStructure}) VALUES (${descriptorsTableValPlaceholders})`);
  
              /* === RECORD CREATION STAGE === */
              const hash = crypto.createHash('sha256').update(descriptor); // create the needed hash (I chose to use a hash representation of the descriptor for which I know it will be trully unique).
  
              /* create and hidrate the array */
              let descriptorsRowIdxsReordered = []; // the array of the values bound to be inserted into the table
              descriptorsRowIdxsReordered[0] = hash.digest('hex'); // the value for `hash` column
              descriptorsRowIdxsReordered[1] = descriptor;  // the value for `descriptor` column
              descriptorsRowIdxsReordered[2] = `${JSON.stringify({values: [row['Year']]})}`; // the value for `Year` column
              descriptorsRowIdxsReordered[3] = `${JSON.stringify({values: [row['JournalAccr']]})}`; // the value for `JournalAccr` column
  
              // #B run the query
              await stmt.bind(descriptorsRowIdxsReordered);
  
              // #C Finalize!
              let result = await stmt.get();
  
              // Create all the edges here and insert it in the edges table
              let edge = [];
              edge[0] = descriptorsRowIdxsReordered[0]; // [Source:string]
              edge[1] = row['Id']; // [Target:string] this value is the id for the name of the article
              edge[2] = 1; // [Weight:integer]
              edge[3] = "Directed"; // [Type:string]
              edge[4] = "descriptor"; // [Kind:string]
              edge[5] = row['Label']; // [ArticleTitle:string]
              edge[6] = row['Year']; // [Year:integer]
              edge[7] = row['JournalAccr']; // [JournalAccr:string]
  
              if (edge.length === 8) {
                await createAnEdge(edge);
              }
  
              let TrackerObj = {
                descriptor,
                hash: descriptorsRowIdxsReordered[0],
                origin: row             
              }
              await fs.writeFile('./logs/tracker.json', `${JSON.stringify(TrackerObj , null, 2)},`, 'utf8');
            }
          }      
        }
      } catch (error) {
        throw new Error(`From descriptorAndEdgeCreator() : ${error}`);
      }
    };

    /**
     * Function generates al the possible pairing between certain identifiers
     * Helper function for `createArticleToArticleEdge` function
     * @param {Array} arr 
     * @returns {Array} combinations
     */
    function* generateDistinctPairs(array) {
      for (let i = 0; i < array.length; i++) {
        for (let j = i + 1; j < array.length; j++) {
          yield [array[i], array[j]];
        }
      }
    };

    /**
     * Function creates all possible edges having for source and target article identifiers.
     * It is the callback for the foreach in the `articlesGraphCreator` function
     * Receives as value of the parameter one whole row from descriptor's table 
     * @param {Object} descriptorRecord 
     */
    async function createArticleToArticleEdge (descriptorRecord) {
      try {
        // console.log(`${inspect(descriptorRecord['hash'])}`);    
        // use the hash to search for all the records in the entities table
        if (descriptorRecord['hash']) {
          // console.log(`${descriptorRecord['hash']}`);
          db.all(`SELECT * FROM edges WHERE Source="${descriptorRecord['hash']}"`, async (error, records) => {
            if (error) {
              throw new Error (`Something happened when I tried to fetch the data: ${error}`);
            }
            // console.log(records);
            let articlesIds = records.map(rec => rec['Target']);

            // console.log(`The Ids I need are  ${JSON.stringify(articlesIds)}`);
            if (articlesIds.length >= 2 && articlesIds.length <= 5) {
              // console.log(`This segment has ${articlesIds.length} Ids`);
              // if (articlesIds.length > 5) {
              //   console.log(`Better check this one out ${JSON.stringify(articlesIds)} for the ${descriptorRecord['hash']}\n`);
              //   fs.appendFile('./biggerthan5.csv', `${JSON.stringify(articlesIds)} for the ${descriptorRecord['hash']}\n`, 'utf8');
              // }
              
              
              // You better have at least 8 cores for this :)))) MUHHAHAHAHAHAHAHA!
              let newEdges = generateDistinctPairs(articlesIds); // gives you all the possible combinations
              for (let combo of newEdges) {
                // let sourceRowData = await getRecordsFromTable(articles, Id, combo[0]);
                // let targetRowData = await getRecordsFromTable(articles, Id, combo[1]);
                db.each(`SELECT * FROM 'articles' WHERE 'Id'="${combo[0]}"`, (error, combo0Rec) => {
                  if (error) {
                    throw new Error (`An error has been issued when accessing the articles table trying to get data for the article in the <Source> position: ${error}`);
                  }
                  // data for the article in the `Source` position
              
                  // And down to the pyramid of dooooooommmmmm! Save me Obi Wan! You are my only hope!
                  db.each(`SELECT * FROM 'articles' WHERE 'Id'="${combo[1]}"`, async (error, combo1Rec) => {
                    if (error) {
                      throw new Error (`An error has been issued when accessing the articles table trying to get data for the article in the <Target> position: ${error}`);
                    }
                    // data for the article in the `Target` position
                    let newArticleEdge = [...combo, 1, "Undirected", descriptorRecord['descriptor'], " ", `${combo0Rec['Year']},${combo1Rec['Year']}`,  `${combo0Rec['JournalAccr']},${combo1Rec['JournalAccr']}`];
                    console.log(`The inbound edge: ${newArticleEdge}`);
                    let line = newArticleEdge.join('","') + '\n';
                    if (newArticleEdge.length === 8) {
                      fs.appendFile(`./articledges.csv`, line, 'utf8');
                      // await createAnEdge(newArticleEdge);
                    }
                  });  
                });
              }
            }
          });
        }
      } catch (error) {
        throw new Error(error);
      }
    };

    /**
     * Function is creating edges for every articles that are linked through a common descriptor
     * The descriptor is treated as a verb (name of the edge)
     * @param {*} row The row of data for an article who's keywords are being processed
     */
    function articlesGraphCreator (row) {
      let KwObj = JSON.parse(row['Kw']); // parse the object value in in Kw
      let kwArr = KwObj['values'];       // set `kwArr` -> should be an array
      // console.log(`The descriptor array for this row is ${JSON.stringify(kwArr)}`);

      for (let descriptor of kwArr) {
        db.each(`SELECT * FROM descriptors WHERE descriptor="${descriptor}"`, function clbkDescrPaitToArts (error, descrData) {
          if (error) {
            throw new Error (`Selecting all data from the table descriptors, this error was thrown: ${error}`);
          }        
          // console.log(`${inspect(descrData)}`);
          createArticleToArticleEdge(descrData);
        });
      }
    }


    /**
     * The function enriches descriptors with supplementary
     * data as far as the same descriptor is encontered in 
     * another article. Enrichment with the year and accr
     * It will be called for every keyword in the article's keyword array
     * It will add years for the same descriptor where this one shows up for the articles
     * It will create edges in certain cases
     * Calls `createAnEdge()`
     * Calls `addOneValueToAJSONarr`
     */
    async function enrichDescriptors () {
      try {
        // process descriptors
        let allArticles = await db.all(`SELECT * FROM articles`);

        // parse the result
        for (let articleRow of allArticles) {

          let KwObj = JSON.parse(articleRow['Kw']); // parse the object value in in Kw
          let kwArr = KwObj['values'];              // set `kwArr` -> should be an array
    
          for (let descriptor of kwArr) {    
            if (descriptor === undefined) {
              throw new Error (`This article <${articleRow.Label}> has a descriptor problem investigated as: ${inspect(descriptor)}`);
            }
            // get the row from descriptors table for the passed value
            const descriptorRow = await db.get(`SELECT * FROM descriptors WHERE descriptor="${descriptor}"`);

            // if you get a row from descriptors table
            if (descriptorRow) {
              /* === Work with the existing Years array === */
              // Extract the year and compare with the values already existing
              let yearsParsed = JSON.parse(descriptorRow['Years']);   // transform the JSON text into an object
              let resultExistingYears = yearsParsed['values']; // extract the array
      
              // Check to have a real array in the value. Bit me very nasty!
              if (typeof(resultExistingYears) === 'string') {
                resultExistingYears = JSON.parse(resultExistingYears);
              }
      
              // first test if there is an array of years
              if (Array.isArray(resultExistingYears)) {
                if (articleRow['Year'] !== undefined && !resultExistingYears.includes(articleRow['Year'])) {
                  resultExistingYears.push(articleRow['Year']);
                } // update the years to include the new year as well
              } else {
                throw new Error (`There is something fishy with this tranformation. 
                I expected an array and came about this ${resultExistingYears} which is revealed to be: ${inspect(resultExistingYears)}. 
                Test 4 arr: ${Array.isArray(resultExistingYears)}
                The resultExistingYears back to JSON is: ${JSON.stringify(resultExistingYears)}.
                Is it a string: ${typeof(resultExistingYears) === 'string'}.
                But noow ${Array.isArray(JSON.parse(resultExistingYears))}
                `);
              }
      
              /* === Work with the existing JournalAccrs array === */
              let JournalAccrs = JSON.parse(descriptorRow['JournalAccrs']);  // transform the JSON text into an object
              let resultExistingJournalAccrs = JournalAccrs['values'];// extract the array
      
              // Check to have a real array in the value. Bit me very nasty!
              if (typeof(resultExistingJournalAccrs) === 'string') {
                resultExistingJournalAccrs = JSON.parse(resultExistingJournalAccrs);
              }
      
              // first test id there is an aray of values
              if (Array.isArray(resultExistingJournalAccrs)) {
                if (descriptorRow['JournalAccr'] !== undefined && !resultExistingJournalAccrs.includes(descriptorRow['JournalAccr'])) {
                  resultExistingJournalAccrs.push(articleRow['JournalAccr'])
                } // update de Accrs to include the new journal accr as well
              } else {
                throw new Error (`There is something fishy with this tranformation. I expected an array and came about this ${inspect(resultExistingJournalAccrs)}`);
              }
              let now = new Date();
              let shoutout = `For the existing descriptor with id <${descriptorRow.descriptor}>, value of JournalAccrs is ${descriptorRow['JournalAccrs']}, and ${descriptorRow['Years']} transformed into ${JSON.stringify(JournalAccrs)}, and ${JSON.stringify(resultExistingYears)}.\n`;
              fs.appendFile(`./logs/descriptorenrichment.log`, `[${now.toUTCString()}] : ${shoutout}`, 'utf-8');
      
              // prepare the new edge now that we have done enrichments
              let newEdge = [];
              newEdge[0] = descriptorRow['hash'];     // [Source:string]
              newEdge[1] = articleRow['Id'];          // [Target:string] this value is the id for the name of the article
              newEdge[2] = 1;                         // [Weight:integer]
              newEdge[3] = "Directed";                // [Type:string]
              newEdge[4] = "descriptor";              // [Kind:string]
              newEdge[5] = articleRow['Label'];       // [ArticleTitle:string]
              newEdge[6] = articleRow['Year'];        // [Year:integer]
              newEdge[7] = articleRow['JournalAccr']; // [JournalAccr:string]
            
              /* === Enrichment stages according to missing or existing of years or Accrs === */
              // The case when the year and the JournalAccr are missing from their coresponding arrays of the descriptor
              if (!resultExistingYears.includes(articleRow['Year'] && !resultExistingJournalAccrs.includes(articleRow['JournalAccr']))) {        
                // if the `Year` value in the row (of the `descriptors` table) doesn't exist
                let queryStringForAmmendYearsArray = `
                  UPDATE descriptors 
                  SET 
                    Years = json_set(Years, '$.values', ?), 
                    JournalAccrs = json_set(JournalAccrs, '$.values', ?)
                  WHERE hash = ?
                `;
            
                let descriptorModified = await db.run(queryStringForAmmendYearsArray, [JSON.stringify(resultExistingYears), JSON.stringify(resultExistingJournalAccrs), descriptorRow['hash']]);
                
                if (descriptorModified.changes === 1) {
                  // create a new edge for this case when the descriptor shows up at another year, another journal/conference (venue)
                  if (newEdge.length === 8) {
                    await createAnEdge(newEdge);
                  }
                  // Log the success message
                  console.log(`${this.changes} enrichment for descriptor: ${descriptorRow['descriptor']}`);
                }

              } else if (!resultExistingYears.includes(row['Year'])) {
                // treat the case when only the value or the `Year` is different
                await addOneValueToAJSONarr('descriptors', 'Years', 'values', JSON.stringify(resultExistingYears));
                // create a new edge for the case when a descriptor shows up in another year
                if (newEdge.length === 8) {
                  await createAnEdge(newEdge);
                }
              } else if (!resultExistingJournalAccrs.includes(articleRow['JournalAccr'])) {
                // treat the case when the accronim of the venue doesn't exist
                await addOneValueToAJSONarr('descriptors', 'JournalAccrs', 'values', JSON.stringify(resultExistingJournalAccrs));
                // treat the case when the descriptor shows up at the same year but to another article at another venue
                if (newEdge.length === 8) {
                  await createAnEdge(newEdge);
                }
              } 
            } else {
              let now = new Date();
              if (descriptorRow === undefined) {
                console.log(`In descriptor's table I don't have the one you search [${descriptor}].`);
                fs.appendFile(`./logs/enrichmentIssues.log`, `[${now.toUTCString()}] : I don't have a record in descriptors. Value undefined\n`, 'utf-8');
                return;
              }   
            }
          }

        }
      } catch (error) {
        throw new Error (error);
      }
    }

    /**
     * Function will enrich all the records in the descriptors table
     * It will be called for every keyword in the article's keyword array
     * It will add years for the same descriptor where this one shows up for the articles
     * It will create edges in certain cases
     * @param {String} descriptor
     * @param {Object} row is a row from the `articles` table
     */
    function enrichDescriptorNodes (descriptor, row) {
      // get my data
      db.get(`SELECT * FROM descriptors WHERE descriptor="${descriptor}"`, async function clbkChec4ExistanceOfDescr (error, result) {
        if (error) {
          throw new Error (`Searching for the descriptor, I came upon this error: ${error}`);
        } 
        let now = new Date();
        if (result === undefined) {
          console.log(`In descriptor's table I don't have the one you search. Value is undefined`);
          fs.appendFile(`./logs/enrichmentIssues.log`, `[${now.toUTCString()}] : I don't have a record in descriptors. Value undefined\n`, 'utf-8');
          return;
        }     

        /* === Work with the existing Years array === */
        // Extract the year and compare with the values already existing
        let yearsParsed = JSON.parse(result['Years']);   // transform the JSON text into an object
        let resultExistingYears = yearsParsed['values']; // extract the array

        // Check to have a real array in the value. Bit me very nasty!
        if (typeof(resultExistingYears) === 'string') {
          resultExistingYears = JSON.parse(resultExistingYears);
        }

        // first test if there is an array of years
        if (Array.isArray(resultExistingYears)) {
          if (row['Year'] !== undefined && !resultExistingYears.includes(row['Year'])) {
            resultExistingYears.push(row['Year']);
          } // update the years to include the new year as well
        } else {
          throw new Error (`There is something fishy with this tranformation. 
          I expected an array and came about this ${resultExistingYears} which is revealed to be: ${inspect(resultExistingYears)}. 
          Test 4 arr: ${Array.isArray(resultExistingYears)}
          The resultExistingYears back to JSON is: ${JSON.stringify(resultExistingYears)}.
          Is it a string: ${typeof(resultExistingYears) === 'string'}.
          But noow ${Array.isArray(JSON.parse(resultExistingYears))}
          `);
        }

        /* === Work with the existing JournalAccrs array === */
        let JournalAccrs = JSON.parse(result['JournalAccrs']);  // transform the JSON text into an object
        let resultExistingJournalAccrs = JournalAccrs['values'];// extract the array

        // Check to have a real array in the value. Bit me very nasty!
        if (typeof(resultExistingJournalAccrs) === 'string') {
          resultExistingJournalAccrs = JSON.parse(resultExistingJournalAccrs);
        }

        // first test id there is an aray of values
        if (Array.isArray(resultExistingJournalAccrs)) {
          if (row['JournalAccr'] !== undefined && !resultExistingJournalAccrs.includes(row['JournalAccr'])) {
            resultExistingJournalAccrs.push(row['JournalAccr'])
          } // update de Accrs to include the new journal accr as well
        } else {
          throw new Error (`There is something fishy with this tranformation. I expected an array and came about this ${inspect(resultExistingJournalAccrs)}`);
        }

        let shoutout = `For the existing descriptor with id <${result.descriptor}>, value of JournalAccrs is ${result['JournalAccrs']}, and ${result['Years']} transformed into ${JSON.stringify(JournalAccrs)}, and ${JSON.stringify(resultExistingYears)}.\n`;
        fs.appendFile(`./logs/descriptorenrichment.log`, `[${now.toUTCString()}] : ${shoutout}\n`, 'utf-8');

        // prepare the new edge now that we have done enrichments
        let newEdge = [];
        newEdge[0] = result['hash'];     // [Source:string]
        newEdge[1] = row['Id'];          // [Target:string] this value is the id for the name of the article
        newEdge[2] = 1;                  // [Weight:integer]
        newEdge[3] = "Directed";         // [Type:string]
        newEdge[4] = "descriptor";       // [Kind:string]
        newEdge[5] = row['Label'];       // [ArticleTitle:string]
        newEdge[6] = row['Year'];        // [Year:integer]
        newEdge[7] = row['JournalAccr']; // [JournalAccr:string]
      
        /* === Modification stages === */
        // The case when the year and the JournalAccr are missing from their coresponding arrays of the descriptor
        if (!resultExistingYears.includes(row['Year'] && !resultExistingJournalAccrs.includes(row['JournalAccr']))) {        
          // if the `Year` value in the row (of the `descriptors` table) doesn't exist
          let queryStringForAmmendYearsArray = `
            UPDATE descriptors 
            SET 
              Years = json_set(Years, '$.values', ?), 
              JournalAccrs = json_set(JournalAccrs, '$.values', ?)
            WHERE hash = ?
          `;
      
          db.run(queryStringForAmmendYearsArray, [JSON.stringify(resultExistingYears), JSON.stringify(resultExistingJournalAccrs), result['hash']], async function clbkUpdateTwoVals (error) {
            if (error) {
              throw new Error (`By the moment I tried to update the two values, this error appeared ${error.message}`);
            }
            // create a new edge for this case when the descriptor shows up at another year, another journal/conference (venue)
            if (newEdge.length === 8) {
              await createAnEdge(newEdge);
            }
            // Log the success message
            console.log(`${this.changes} enrichment for descriptor: ${result['descriptor']}`);
          });
        } else if (!resultExistingYears.includes(row['Year'])) {
          // treat the case when only the value or the `Year` is different
          addOneValueToAJSONarr('descriptors', 'Years', 'values', JSON.stringify(resultExistingYears));
          // create a new edge for the case when a descriptor shows up in another year
          if (newEdge.length === 8) {
            await createAnEdge(newEdge);
          }
        } else if (!resultExistingJournalAccrs.includes(row['JournalAccr'])) {
          // treat the case when the accronim of the venue doesn't exist
          addOneValueToAJSONarr('descriptors', 'JournalAccrs', 'values', JSON.stringify(resultExistingJournalAccrs));
          // treat the case when the descriptor shows up at the same year but to another article at another venue
          if (newEdge.length === 8) {
            await createAnEdge(newEdge);
          }
        }
      });
    };

    // db.close(); // in the end close connection with the database
  } catch (error) {
    console.log(error);
    let now = new Date();
    let logline = `[${now.toUTCString()}] «Error»: ${error.message}`;
    fs.appendFile(`./logs/error.log`, `${logline}\n`, 'utf8');
  }
})()