import fs from 'node:fs/promises';
import { finished } from 'stream/promises';
import { parse } from 'csv-parse';
import inquirer from 'inquirer';
import logUpdate from 'log-update';
import { consola, createConsola } from "consola";
// import {connectToDatabase} from './db.js'; // https://github.com/kriasoft/node-sqlite
// import * as connection from './db.js'; // https://github.com/kriasoft/node-sqlite
import test4empty from './util/empty.js';
import {inspect} from 'util';

let crypto;
try {
    crypto = await import('node:crypto');
} catch (err) {
    console.error('crypto support is disabled!');
} 

// connect to database
import sqlite3 from 'sqlite3';
import { open } from 'sqlite'


(async function app () {
  try {
    sqlite3.verbose();

    let sourcefilename = `./sourcefile/data-adoua-forma.csv`;

    const db = await open({
      filename: '/home/nicolaie/Desktop/DEVELOPMENT/GnodEdge/publications.sqlite',
      driver: sqlite3.Database
    });

    // db.on('trace', (data) => {
    //   logUpdate(data);
    // })

    /* === PRIMARY SETTING UP for `articles` table (considered the primary node table) === */
    // for this scenario, the nodes are the titles of the articles and their corresponding ids are generated by Zotero at export time as CSV
    let nodesTabelHeadStructure = `Id,Label,` + `Year,Author,JournalAccr,Kw`; // Mind that the `Id` and `Label` should be strict as such. The rest of the atributes may be of your own choosing
    let nodesIdxsAreArrays = [2, 5]; // The values at these indexes are actualy arrays
    let nodesTableRecordMarcherIdxs = [0, 3, 1, 2, 4, 5]; // These are the indexes of every value in an array representing a line from the CSV. This is useful when you want some other entity as node value (`Label`)
    let nodesTableValPlaceholders   = `?, ?, ?, json(?), ?, json(?)`; // the number of the question marks should match the number of the values in the head (`nodesTabelHeadStructure`). The coding as JSON is essential for quering.
    let mainTablename = `articles`;
    // the query needed to create `articles` table
    let tableExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='${mainTablename}'`;
    // QUERY needed for creating the table
    let tblCreateQuery = `
    CREATE TABLE IF NOT EXISTS articles (
        Id           VARCHAR(10),
        Label        VARCHAR(250),
        Year         INTEGER,
        Author       json,
        JournalAccr  VARCHAR(20),
        Kw           json
    )
    `;
    /* === Descriptors table === */
    let descriptorsExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='descriptors'`;
    let descriptorsTabelHeadStructure = `hash,descriptor,Years,JournalAccrs`;
    let descriptorsTableValPlaceholders   = `?, ?, ?, ?`;
    let descriptorsTblName = 'descriptors';
    let tblDescriptorsExists = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='${descriptorsTblName}'`;
    let tblDescriptorsCreateQuery = `
    CREATE TABLE IF NOT EXISTS descriptors (
        id           INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
        hash         VARCHAR(50),
        descriptor   VARCHAR(250),
        Years        json,
        JournalAccrs json
    )
    `;
    /* === Edges table === */
    let edgesExistsQuery = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='edges'`;
    let edgesTabelHeadStructure = `Source,Target,Weight,Type,Kind,Article,Year,JournalAccr`;
    let edgesTableValPlaceholders = `?, ?, ?, ?, ?, ?, ?, ?`;
    let edgesTblName = 'edges';
    let tblEdgesExists = `SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='${edgesTblName}'`;
    let tblEdgesCreateQuery = `
    CREATE TABLE IF NOT EXISTS edges (
        id           INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
        Source       VARCHAR(50),
        Target       VARCHAR(50),
        Weight       INTEGER,
        Type         VARCHAR(20),
        Kind         VARCHAR(20),
        Article      VARCHAR(300),
        Year         INTEGER,
        JournalAccr  VARCHAR(20)
    )
    `;

    // let articlesExists = db.get(tableExistsQuery, (e, r) => {
    //   if (e) console.error;
    //   // console.log(r)
    // });

    // let a = await db.get(`SELECT count(*) as result FROM sqlite_master WHERE type='table' AND name='articles'`);
    // const result = await db.get('SELECT Label FROM articles WHERE Label = ?', 'Growth and Server Availability of the NCSTRL Digital Library');
    // console.log(a);

    let articlesExists = await db.get(tableExistsQuery);
    let descriptorsExists = await db.get(tblDescriptorsExists);
    let edgesExists = await db.get(tblEdgesExists);

    if (articlesExists.result === 1) {
      console.log(`The table articles already exists, ol' chap!`);
    } else {
      await db.exec(tblCreateQuery);
    }

    if (descriptorsExists.result === 1) {
      console.log(`Table descriptors already exists, jolly lassie!`);
    } else {
      await db.exec(tblDescriptorsCreateQuery);
    }

    if (edgesExists.result === 1) {
      console.log(`Table edges already exists, silly bat!`);
    } else {
      await db.exec(tblEdgesCreateQuery);
    }

    let x = await Promise.all([db.get(tableExistsQuery), db.get(tblDescriptorsExists), db.get(tblEdgesExists)]);
    let tablesOK = x.every((element) => {
      return element.result === 1;
    })

    let noDescrExisting = 0; // needed for counting doubles in descriptors table. Needs be declared before running stagesProcessing()
    let noEdgesSearch = 0; // needed for counting doubles in edges table. Needs be declared before running stagesProcessing()

    if (tablesOK) {
      let noTblArticles = await db.get(`SELECT count(*) as artNrs FROM articles`);
      // if articles tabel is empty, hidrate
      if (!noTblArticles.artNrs > 0) {
        await populateArticlesTable();
      }
    }

    /**
     * Encapsulated functions needed for articles table hidration
     * @returns {Boolean}
     */
    async function populateArticlesTable () {
      /**
       * Function is a callback for `on("data", clbkWorkOnRow)`
       * This is the place whre table articles gets hidrated
       *  with data from the chunk
       * @param {Object} row 
       */
      async function processDataRow(row) {
        try {
          // prepare an Sqlite3 statement and load the data
          let stmt = await db.prepare(`INSERT INTO articles(${nodesTabelHeadStructure}) VALUES (${nodesTableValPlaceholders})`);
          // Insert into the articles the data
          await stmt.bind(nodesTableRecordMarcherIdxs.map((idx) => {
            // set JSON value
            let now = new Date();
            if (nodesIdxsAreArrays.includes(idx)) {            
              let valuesArr = row[idx].split('; '); // the array of values 
              if (valuesArr.length > 0) {
                // console.log(`The values when we have actualy an array ${JSON.stringify(valuesArr)}`); // ["Silva, Paulo","Matos, Miguel","Barreto, João"]
                return `${JSON.stringify(valuesArr)}`;
              } else {
                console.log(`I have inserted in article table entity ${row[1]}`);            
                let logline = `[${now.toUTCString()}] «clbkWorkOnRow(row)»: I have inserted in article table: ${row[idx]}.\n`;
                fs.appendFile(`./logs/main.log`, `${logline}`, 'utf8');
                return `${row[idx]}`;
              }  
            } else {
              let logline = `[${now.toUTCString()}] «clbkWorkOnRow(row)»: I have inserted in article table: ${row[idx]}.\n`;
              fs.appendFile(`./logs/main.log`, logline, 'utf8');
              return row[idx];
            }
          }));
          await stmt.get();
        } catch (error) {
          throw new Error(error);
        }
      };

      /**
       *The function is populating the `articles` table with the data 
      *from the source file
      */
      async function dataProcessor () {
        try {
        // read the file source
        const fd = await fs.open(sourcefilename);
        fd.createReadStream()
            .pipe(parse({ delimiter: ",", from_line: 2, skip_empty_lines: true, trim: true }))
            .on("data", async function clbkWorkOnRow(row) {
              await processDataRow(row);
            })
            .on("end", function () {
                console.log(`I've finished reading the CSV. Data is still being writen in the articles table`);
            })
            .on("error", function (error) {
                throw new Error(error);
            });
        return true;
        } catch (error) {
          throw new Error (`From populateArticlesTable: ${error}`);
        }
      };
      return await dataProcessor();
    };

    let clearing = new Set(); // clearing house for the descriptors
    let noOfDescrProcessed = 0;
    /**
     * The function will process the rest of the steps:
     * creating data in descriptors and building edges
     * Calls `populateArticlesTable()`
     * Calls `descriptorAndEdgeCreator(row)`
     * Calls `enrichDescriptors()`
     */
    async function stagesProcessing () {
      try {
        // out of every row in articles, generate descriptors and primary edges
        let articlesRows = await db.each(`SELECT * FROM articles`, async function clbkparseDataOneTbl (error, row) {
          if (error) {
            throw new Error (`Selecting all data from the table articles, this error was thrown: ${error}`);
          }

          if (row) {
            await descriptorAndEdgeCreator(row);
          } else {
            throw new Error(`I was expecting a row from articles table and I've got this: ${inspect(row)}`);
          }
        });

        // if (articlesRows > 0) {
        //   /* === proceed with deep enrichment === */
        //   await enrichDescriptor(null, null, null, false);
        // }
        // console.log(`The number of records in articles table is: ${JSON.stringify(articlesRows)}`);

      } catch (error) {
        throw new Error (`From stagesProcessing() : ${error}`);
      }
    };

    // process the stages of creating the descriptors and the primary edges      
    // await stagesProcessing();

    await enrichDescriptor(null, null, null, false);
    /* ---------------------------------------------------------------------------------------------------------------------------- */

    /**
     * Function creates a new record in the `edges` table
     * @param {Array} recordArray 
     */
    async function createAnEdge (recordArray) {
      // 0825efc283c9919d0363e3dae5d34490ad1966e5fb47fb7056f5c3029838bde3,97FE9V2W,1,Directed,descriptor,FREME: A Framework for Multilingual and Semantic Enrichment of Digital Content,2016,SWIB
      try {
        let edgesSearched = await db.get(`SELECT * FROM edges WHERE Source=? AND Target=?`, [recordArray[0], recordArray[1]]);
        // logUpdate(`I searched the edges and I found ${JSON.stringify(edgesSearched)}`);
        if (edgesSearched === undefined) {

          // #A Prepare the statement
          let stmt = await db.prepare(`INSERT INTO edges(${edgesTabelHeadStructure}) VALUES (${edgesTableValPlaceholders})`);
  
          // #B run the query
          if (Array.isArray(recordArray)) {
            await stmt.bind(recordArray);
          } else {
            throw new Error (`I dont have an array for the recordArray value`);
          }           
  
          // #C Finalize!
          await stmt.get();
        }
        noEdgesSearch++;
        return;
      } catch (error) {
        throw new Error(`From createAnEdge: ${error}`);
      }
    };

    /**
     * The function adds one value to an array existing in 
     * a JSON value of a cell in a particular table
     * If there is no such JSON object, the moded value will overwrite the existing 
     * @param {String} tableName The name of the table you target
     * @param {String} columName The name of the column the JSON value is
     * @param {String} keyName The name of the key under which the JSON object resides 
     * @param {JSON} mod The modified value that will replace the existing one
     * @param {String} colTarget Name of the column in `WHERE` selection
     * @param {String} colValue The value for the targeted colum in `WHERE` selection
     */
    async function addOneValueToAJSONarr (tableName, columName, keyName, mod, colTarget, colValue) {
      try {
        if (typeof(mod) !== 'string') {
          throw new Error (`The value I expected for modified value was a plain string of JSON, I received this: ${inspect(mod)}`);
        }
        if (typeof(colTarget) !== 'string') {
          throw new Error (`The value I expected for colum name used in WHERE was a plain string, and I received this: ${inspect(colTarget)}`);
        }
        if (typeof(colValue) !== 'string') {
          throw new Error (`The value I expected for value used in WHERE was a plain string, and I received this: ${inspect(colValue)}`);
        }

        if (mod !== undefined) {
          // treat case when there is no keyName
          let target = undefined;
          if (keyName === undefined) {
            target = `?`;
          } else {
            target = `json_set(${columName}, '$.${keyName}', ?)`;
          }
          // build the query
          let query = `
            UPDATE ${tableName}
            SET ${columName} = ${target} 
            WHERE ${colTarget} = ?;
          `;
          // let targetModified = await db.run(query, [`${mod}`, `${colValue}`]);

          // if (targetModified.changes === 1) {
          //   let now = new Date();
          //   let descEnriched = `${this.changes} enrichment for descriptor: ${columName}\n`;
          //   fs.appendFile(`./logs/descriptorenrichment.log`, `[${now.toUTCString()}] : ${descEnriched}`, 'utf-8');
          // }

          let stmt = await db.prepare(query);
          await stmt.bind([`${mod}`, `${colValue}`]);
          await stmt.get();

        } else {
          throw new Error(`The value you want to update the field with not ok: ${inspect(mod)}`);
        }
      } catch (error) {
        throw new Error(`[addOneValueToAJSONarr]: ${error}`);
      }
    }

    
    /**
     * Function pushes descriptors in `descriptors` table.
     * It also pushes the first edge in the edge table.
     * It checks is the descriptor exists already, and if it does, 
     * It checks if the other attributes are already in the columns meant to gather it: 
     *  - (year[array] and the journal accronim[array])
     * Criteria: `SELECT DISTINCT descriptor FROM descriptors WHERE descriptor="${descriptor}"` 
     * Calls `createAnEdge(edge)`
     * @param {String} row It is a whole row from the articles table 
     */
    async function descriptorAndEdgeCreator (row) {
      try {
        let kwArr = JSON.parse(row['Kw']); // parse the object value in in Kw  
        if (Array.isArray(kwArr)) {
          for (let i of kwArr) {
            if (clearing.has(i)) {
              continue;
            } else {
              clearing.add(i)
              /* === DESCRIPTOR RECORD CREATION STAGE === */
              const hash = crypto.createHash('sha256').update(i).digest('hex'); // create the needed hash (I chose to use a hash representation of the descriptor for which I know it will be trully unique).

              /* create and hidrate the array of values for one row in descriptors table */
              let descriptorsRowIdxsReordered = [];                                        // the array of the values bound to be inserted into the table
              descriptorsRowIdxsReordered[0]  = hash;                                      // the value for `hash` column
              descriptorsRowIdxsReordered[1]  = i;                                // the value for `descriptor` column
              descriptorsRowIdxsReordered[2]  = JSON.stringify([row['Year']]);        // the value for `Year` column MUST BE an Array
              descriptorsRowIdxsReordered[3]  = JSON.stringify([row['JournalAccr']]); // the value for `JournalAccr` column MUST BE an Array
              
              // console.log(`The array I have prepared to pass as values is ${inspect(descriptorsRowIdxsReordered)}`);
              let descriptorExisting = await db.get(`SELECT DISTINCT * FROM descriptors WHERE hash = ?`, hash);
              // consola.info(`Obj is ${descriptorExisting}`);
              if (descriptorExisting === undefined) {                
                let descriptorRecordJustInserted = await db.run(`INSERT INTO descriptors(${descriptorsTabelHeadStructure}) VALUES (${descriptorsTableValPlaceholders})`, descriptorsRowIdxsReordered);
                consola.info(`Last descriptor in: ${descriptorRecordJustInserted.lastID}`);
              } else {
                noDescrExisting++;
                // consola.info(`BANG:`, JSON.stringify(descriptorExisting));
                await enrichDescriptor(i, descriptorExisting, row, true); // true means you only want one enrichment from the current row from articles. At a latter stage procede with full enrichment
              }              

              /* === Create the primary edge === */
              // Create the data for one row to the edges table
              let edge = [];
              edge[0] = descriptorsRowIdxsReordered[0]; // [Source      :string  ]
              edge[1] = row['Id'];                      // [Target      :string  ] this value is the id for the name of the article
              edge[2] = 1;                              // [Weight      :integer ] «hardcoded»
              edge[3] = "Directed";                     // [Type        :string  ] «hardcoded»
              edge[4] = "descriptor";                   // [Kind        :string  ] «hardcoded»
              edge[5] = row['Label'];                   // [ArticleTitle:string  ]
              edge[6] = row['Year'];                    // [Year        :integer ]
              edge[7] = row['JournalAccr'];             // [JournalAccr :string  ]
              // write the primary edge
              if (edge.length === 8) {
                await createAnEdge(edge); // Error: Error: SQLITE_RANGE: column index out of range
              }
              noOfDescrProcessed++;
            }            
          }          
        }
        return {descriptors: "done", primaryEdges: "done", enrichment: "done"};
      } catch (error) {
        throw new Error(`From descriptorAndEdgeCreator() : ${error}`);
      }
    };
    /**
     * Function generates al the possible pairing between certain identifiers
     * Helper function for `createArticleToArticleEdge` function
     * @param {Array} arr 
     * @returns {Array} combinations
     */
    function* generateDistinctPairs(array) {
      for (let i = 0; i < array.length; i++) {
        for (let j = i + 1; j < array.length; j++) {
          yield [array[i], array[j]];
        }
      }
    };

    /**
     * Function creates all possible edges having for source and target article identifiers.
     * It is the callback for the foreach in the `articlesGraphCreator` function
     * Receives as value of the parameter one whole row from descriptor's table 
     * @param {Object} descriptorRecord 
     */
    async function createArticleToArticleEdge (descriptorRecord) {
      try {
        // console.log(`${inspect(descriptorRecord['hash'])}`);    
        // use the hash to search for all the records in the entities table
        if (descriptorRecord['hash']) {
          // console.log(`${descriptorRecord['hash']}`);
          db.all(`SELECT * FROM edges WHERE Source="${descriptorRecord['hash']}"`, async (error, records) => {
            if (error) {
              throw new Error (`Something happened when I tried to fetch the data: ${error}`);
            }
            // console.log(records);
            let articlesIds = records.map(rec => rec['Target']);

            // console.log(`The Ids I need are  ${JSON.stringify(articlesIds)}`);
            if (articlesIds.length >= 2 && articlesIds.length <= 5) {
              // console.log(`This segment has ${articlesIds.length} Ids`);
              // if (articlesIds.length > 5) {
              //   console.log(`Better check this one out ${JSON.stringify(articlesIds)} for the ${descriptorRecord['hash']}\n`);
              //   fs.appendFile('./biggerthan5.csv', `${JSON.stringify(articlesIds)} for the ${descriptorRecord['hash']}\n`, 'utf8');
              // }
              
              
              // You better have at least 8 cores for this :)))) MUHHAHAHAHAHAHAHA!
              let newEdges = generateDistinctPairs(articlesIds); // gives you all the possible combinations
              for (let combo of newEdges) {
                // let sourceRowData = await getRecordsFromTable(articles, Id, combo[0]);
                // let targetRowData = await getRecordsFromTable(articles, Id, combo[1]);
                db.each(`SELECT * FROM 'articles' WHERE 'Id'="${combo[0]}"`, (error, combo0Rec) => {
                  if (error) {
                    throw new Error (`An error has been issued when accessing the articles table trying to get data for the article in the <Source> position: ${error}`);
                  }
                  // data for the article in the `Source` position
              
                  // And down to the pyramid of dooooooommmmmm! Save me Obi Wan! You are my only hope!
                  db.each(`SELECT * FROM 'articles' WHERE 'Id'="${combo[1]}"`, async (error, combo1Rec) => {
                    if (error) {
                      throw new Error (`An error has been issued when accessing the articles table trying to get data for the article in the <Target> position: ${error}`);
                    }
                    // data for the article in the `Target` position
                    let newArticleEdge = [...combo, 1, "Undirected", descriptorRecord['descriptor'], " ", `${combo0Rec['Year']},${combo1Rec['Year']}`,  `${combo0Rec['JournalAccr']},${combo1Rec['JournalAccr']}`];
                    console.log(`The inbound edge: ${newArticleEdge}`);
                    let line = newArticleEdge.join('","') + '\n';
                    if (newArticleEdge.length === 8) {
                      fs.appendFile(`./articledges.csv`, line, 'utf8');
                      // await createAnEdge(newArticleEdge);
                    }
                  });  
                });
              }
            }
          });
        }
      } catch (error) {
        throw new Error(error);
      }
    };

    /**
     * Function is creating edges for every articles that are linked through a common descriptor
     * The descriptor is treated as a verb (name of the edge)
     * @param {*} row The row of data for an article who's keywords are being processed
     */
    function articlesGraphCreator (row) {
      let KwObj = JSON.parse(row['Kw']); // parse the object value in in Kw
      let kwArr = KwObj['values'];       // set `kwArr` -> should be an array
      // console.log(`The descriptor array for this row is ${JSON.stringify(kwArr)}`);

      for (let descriptor of kwArr) {
        db.each(`SELECT * FROM descriptors WHERE descriptor="${descriptor}"`, function clbkDescrPaitToArts (error, descrData) {
          if (error) {
            throw new Error (`Selecting all data from the table descriptors, this error was thrown: ${error}`);
          }        
          // console.log(`${inspect(descrData)}`);
          createArticleToArticleEdge(descrData);
        });
      }
    }

    /**
     * The function enriches descriptors with supplementary
     * data as far as the same descriptor is encontered in 
     * another article. Enrichment with the year and accr
     * It will be called for every keyword in the article's keyword array
     * It will add years for the same descriptor where this one shows up for the articles
     * It will create edges in certain cases
     * Calls `createAnEdge()`
     * Calls `addOneValueToAJSONarr`
     * @param {String} descName This is the name of the descriptor
     * @param {Object} dRow This is a row from descriptors table
     * @param {Object} aRow This is a row from the articles table
     * @param {Boolean} oneDescriptor If tru this means you want enrichment only for one particular descriptor
     */
    async function enrichDescriptor (descName, dRow, aRow, oneDescriptor) {
      try {
        // enrich only one existing descriptor with the year and accr data from the article row in which it was encountered
        if (oneDescriptor) {
          let ayear  = aRow['Year'];
          let aaccr  = aRow['JournalAccr'];
          let dyears = JSON.parse(dRow['Years']);
          let daccrs = JSON.parse(dRow['JournalAccrs']);

          // check if value of year exists in the array
          if (Array.isArray(dyears) && ayear !== undefined && !dyears.includes(ayear)) {
            dyears.push(ayear); // update the years to include the new one well
            await addOneValueToAJSONarr('descriptors', 'Years', '', JSON.stringify(dyears), 'hash', dRow['hash']);
          }

          if (Array.isArray(daccrs) && aaccr !== undefined && !daccrs.includes(aaccr)) {
            daccrs.push(aaccr); // update the years to include the new one well
            await addOneValueToAJSONarr('descriptors', 'JournalAccrs', '', JSON.stringify(daccrs), 'hash', dRow['hash']);
          }
  
          // prepare the new edge now that we have done enrichments
          let newEdge = [];
          newEdge[0] = dRow['hash'];        // [Source:string]
          newEdge[1] = aRow['Id'];          // [Target:string] this value is the id for the name of the article
          newEdge[2] = 1;                   // [Weight:integer]
          newEdge[3] = "Directed";          // [Type:string]
          newEdge[4] = "descriptor";        // [Kind:string]
          newEdge[5] = aRow['Label'];       // [ArticleTitle:string]
          newEdge[6] = aRow['Year'];        // [Year:integer]
          newEdge[7] = aRow['JournalAccr']; // [JournalAccr:string]

          // write the edge
          if (newEdge.length === 8) {
            await createAnEdge(newEdge);
          }
        } 
        else {
          // process descriptors
          let allArticles = await db.all(`SELECT * FROM articles`);
          consola.info(`All the records are ${allArticles.length}`);

          for (let articleRow of allArticles) {
            let kwArr = JSON.parse(articleRow['Kw']); // parse the array in Kw
            for (let descriptor of kwArr) {
              const hash = crypto.createHash('sha256').update(descriptor).digest('hex');
              /* === get the row from descriptors table for the passed value === */
              let descriptorRow = await db.get(`SELECT DISTINCT * FROM descriptors WHERE hash = ?`, hash);
              // consola.info(`Obiectul este ${inspect(descriptorRow)}`);

              let scoreboard = [false, false, false]; // [0:yearsArr] [1:accrsArr] [2:both]

              /* === Work with the existing Years array === */
              // Extract the year and compare with the values already existing
              let yearsArr = JSON.parse(descriptorRow['Years']); // parse JSON value        
              // first test if there is an array of years
              if (Array.isArray(yearsArr)) {
                // every article has one Year value; If you have an year in the article record and that very year is not in the array colected from the descriptor row
                if (articleRow['Year'] !== undefined && !yearsArr.includes(articleRow['Year'])) {
                  yearsArr.push(articleRow['Year']); // update the years to include the new year as well
                  scoreboard[1] = true;
                } 
              }
      
              /* === Work with the existing JournalAccrs array === */
              let accrsArr = JSON.parse(descriptorRow['JournalAccrs']);  // transform the JSON text into an object
              // first test id there is an aray of values
              if (Array.isArray(accrsArr)) {
                if (descriptorRow['JournalAccr'] !== undefined && !accrsArr.includes(articleRow['JournalAccr'])) {
                  accrsArr.push(articleRow['JournalAccr']);
                  scoreboard[1] = true;
                } // update de Accrs to include the new journal accr as well
              }

              // set the last value of the scoreboard
              if (scoreboard[0] && scoreboard[1]) {
                scoreboard[2] = true;
              }

              if (scoreboard[0] === false && scoreboard[1] === false && scoreboard [2] === false) {
                continue;
              }

              // prepare the new edge now that we have done enrichments
              let newEdge = [];
              newEdge[0] = descriptorRow['hash'];     // [Source:string]
              newEdge[1] = articleRow['Id'];          // [Target:string] this value is the id for the name of the article
              newEdge[2] = 1;                         // [Weight:integer]
              newEdge[3] = "Directed";                // [Type:string]
              newEdge[4] = "descriptor";              // [Kind:string]
              newEdge[5] = articleRow['Label'];       // [ArticleTitle:string]
              newEdge[6] = articleRow['Year'];        // [Year:integer]
              newEdge[7] = articleRow['JournalAccr']; // [JournalAccr:string]
              
              let now = new Date();
              /* === Enrichment stages according to missing or existing of years or Accrs === */
              // The case when the year and the JournalAccr are missing from their coresponding arrays of the descriptor
              if (scoreboard[2] === true) {
                await addOneValueToAJSONarr('descriptors', 'Years',        '', JSON.stringify(yearsArr), 'hash', descriptorRow['hash']);
                await addOneValueToAJSONarr('descriptors', 'JournalAccrs', '', JSON.stringify(accrsArr), 'hash', descriptorRow['hash']);
                // create a new edge for this case when the descriptor shows up at another year, another journal/conference (venue)
                if (newEdge.length === 8) {
                  await createAnEdge(newEdge);
                }                  
                let bothYearAndAccr = `Descriptor <${descriptorRow.descriptor}> has been updated on Years and Accrs.\n`;
                await fs.appendFile(`./logs/descriptorenrichment.log`, `[${now.toUTCString()}] : ${bothYearAndAccr}`, 'utf-8');                  
              } else if (scoreboard[0] === true && scoreboard[1] === false) {
                // treat the case when only the value or the `Year` is different
                await addOneValueToAJSONarr('descriptors', 'Years', '', JSON.stringify(yearsArr), 'hash', descriptorRow['hash']);
                // create a new edge for the case when a descriptor shows up in another year
                if (newEdge.length === 8) {
                  await createAnEdge(newEdge);
                }
                let onlyYear = `Descriptor <${descriptorRow.descriptor}> has only an update on Year.\n`;
                await fs.appendFile(`./logs/descriptorenrichment.log`, `[${now.toUTCString()}] : ${onlyYear}`, 'utf-8');
              } else if (scoreboard[0] === false && scoreboard[1] === true) {
                // treat the case when the accronim of the venue doesn't exist
                await addOneValueToAJSONarr('descriptors', 'JournalAccrs', '', JSON.stringify(accrsArr), 'hash', descriptorRow['hash']);
                // treat the case when the descriptor shows up at the same year but to another article at another venue
                if (newEdge.length === 8) {
                  await createAnEdge(newEdge);
                }
                let onlyAccrs = `Descriptor <${descriptorRow.descriptor}> has only an update on Accrs.\n`;
                await fs.appendFile(`./logs/descriptorenrichment.log`, `[${now.toUTCString()}] : ${onlyAccrs}`, 'utf-8');
              }              
            }
          }
          //       let now = new Date();
          //       console.log(`In descriptor's table I don't have the one you search [${descriptor}].`);
          //       fs.appendFile(`./logs/enrichmentIssues.log`, `[${now.toUTCString()}] : I don't have a record in descriptors. Value undefined\n`, 'utf-8');

        }
      } catch (error) {
        throw new Error (error);
      }
    }

    logUpdate(`
      The number of unique descrs ${noOfDescrProcessed}
      The edge exists already. Counting already inserted ones: ${noEdgesSearch}     
      The existing descriptors encountered: ${noDescrExisting} 
    `);

    // db.close(); // in the end close connection with the database
  } catch (error) {
    consola.error(error);
    let now = new Date();
    let logline = `[${now.toUTCString()}] «Error»: ${error.message}`;
    fs.appendFile(`./logs/error.log`, `${logline}\n`, 'utf8');
  }
})()